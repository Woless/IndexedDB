<pre class=metadata>
Title: Indexed Database API (Second Edition)
Shortname: IndexedDB
Abstract: This document defines APIs for a database of records holding
    simple values and hierarchical objects. Each record consists of a key
    and some value. Moreover, the database maintains indexes over records
    it stores. An application developer directly uses an API to locate
    records either by their key or by using an index. A query language can
    be layered on this API. An indexed database can be implemented using a
    persistent B-tree data structure.
Status: ED
Previous Version: https://www.w3.org/TR/IndexedDB/
ED: https://w3c.github.io/IndexedDB/
Level: 2
Editor: Ali Alabbas, alia@microsoft.com
Editor: Joshua Bell, jsbell@google.com
Group: webplatform
Test Suite: https://github.com/w3c/web-platform-tests/tree/master/IndexedDB
</pre>

<pre class=anchors>
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    urlPrefix: browsers.html
        type: dfn
            text: origin; url: #origin
    urlPrefix: workers.html
        type: dfn
            text: worker; url: #worker
    urlPrefix: infrastructure.html
        type: dfn
            text: strictly splitting the string; url: #strictly-split-a-string
            text: structured clone; url: #safe-passing-of-structured-data
            text: structured clone algorithm; url: #safe-passing-of-structured-data
    urlPrefix: webappapis.html
        type: dfn
            text: queue a task; url: #queue-a-task
            text: event handler idl attributes; url: #event-handler-idl-attributes
spec: dom; urlPrefix: https://dom.spec.whatwg.org
    type: idl
        text: DOMError; url: #domerror
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: Promise; url: #sec-promise-objects
        text: Date; url: #sec-date-objects
        text: Array; url: #sec-array-objects
        text: Uint8Array; url: #sec-typedarray-objects
        text: IdentifierName; url: #prod-IdentifierName
        text: TypeError; url: #sec-native-error-types-used-in-this-standard-typeerror
spec: webidl; urlPrefix: https://heycam.github.io/webidl/
    type: dfn
        text: unrestricted double; url: #idl-unrestricted-double
        text: DOMString; url: #idl-DOMString
        text: DOMException; url: #idl-DOMException
        text: sequence<DOMString>; url: #idl-sequence
        text: octet; url: #idl-octet
        text: throw; url: #dfn-throw
        text: rethrow; url: #dfn-throw
        text: getting a copy of the bytes held by a buffer source; url: #dfn-get-buffer-source-copy
</pre>

This is the Second Edition of Indexed Database API. The
<a href="https://www.w3.org/TR/IndexedDB/">First Edition</a>
became a W3C Recommendation on 8 January 2015.

<!-- ============================================================ -->
<h2 id=introduction>Introduction</h2>
<!-- ============================================================ -->

User agents need to store large numbers of objects locally in order to
satisfy off-line data requirements of Web applications. [[WEBSTORAGE]]
is useful for storing pairs of keys and their corresponding values.
However, it does not provide in-order retrieval of keys, efficient
searching over values, or storage of duplicate values for a key.

This specification provides a concrete API to perform advanced
key-value data management that is at the heart of most sophisticated
query processors. It does so by using transactional databases to store
keys and their corresponding values (one or more per key), and
providing a means of traversing keys in a deterministic order. This is
often implemented through the use of persistent B-tree data structures
that are considered efficient for insertion and deletion as well as
in-order traversal of very large numbers of data records.


<aside class=example>
In the following example, the API is used to access a "library"
database that holds books stored by their "isbn" attribute.
Additionally, an index is maintained on the "title" attribute of the
objects stored in the object store. This index can be used to look up
books by title, and enforces a uniqueness constraint. Another index is
maintained on the "author" attribute of the objects, and can be used
to look up books by author.

A connection to the database is opened. If the "library" database did
not already exist, it is created and an event handler creates the
object store and indexes. Finally, the opened connection is saved for
use in subsequent examples.

<pre class=lang-javascript>
var request = indexedDB.open("library");

request.onupgradeneeded = function() {
  // The database did not previously exist, so create object stores and indexes.
  var db = request.result;
  var store = db.createObjectStore("books", {keyPath: "isbn"});
  var titleIndex = store.createIndex("by_title", "title", {unique: true});
  var authorIndex = store.createIndex("by_author", "author");

  // Populate with initial data.
  store.put({title: "Quarry Memories", author: "Fred", isbn: 123456});
  store.put({title: "Water Buffaloes", author: "Fred", isbn: 234567});
  store.put({title: "Bedrock Nights", author: "Barney", isbn: 345678});
};

request.onsuccess = function() {
  db = request.result;
};
</pre>

The following example populates the database using a transaction.

<pre class=lang-javascript>
var tx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");

store.put({title: "Quarry Memories", author: "Fred", isbn: 123456});
store.put({title: "Water Buffaloes", author: "Fred", isbn: 234567});
store.put({title: "Bedrock Nights", author: "Barney", isbn: 345678});

tx.oncomplete = function() {
  // All requests have succeeded and the transaction has committed.
};
</pre>

The following example looks up a single book in the database by title
using an index.

<pre class=lang-javascript>
var tx = db.transaction("books", "readonly");
var store = tx.objectStore("books");
var index = store.index("by_title");

var request = index.get("Bedrock Nights");
request.onsuccess = function() {
  var matching = request.result;
  if (matching !== undefined) {
    // A match was found.
    report(matching.isbn, matching.title, matching.author);
  } else {
    // No match was found.
    report(null);
  }
};
</pre>

The following example looks up all books in the database by author
using an index and a cursor.

<pre class=lang-javascript>
var tx = db.transaction("books", "readonly");
var store = tx.objectStore("books");
var index = store.index("by_author");

var request = index.openCursor(IDBKeyRange.only("Fred"));
request.onsuccess = function() {
  var cursor = request.result;
  if (cursor) {
    // Called for each matching record.
    report(cursor.value.isbn, cursor.value.title, cursor.value.author);
    cursor.continue();
  } else {
    // No more matching records.
    report(null);
  }
};
</pre>

The following example shows how errors could be handled when a request
fails.

<pre class=lang-javascript>
var tx = db.transaction("books", "readwrite");
var store = tx.objectStore("books");
var request = store.put({title: "Water Buffaloes", author: "Slate", isbn: 987654});
request.onerror = function() {
  // The uniqueness constraint of the "by_title" index failed.
  report(request.error);
  // Could call request.preventDefault() to prevent the transaction from aborting.
};
tx.onabort = function() {
  // Otherwise the transaction will automatically abort due the failed request.
  report(tx.error);
};
</pre>

The database connection may be closed when it is no longer needed.

<pre class=lang-javascript>
db.close();
</pre>

In the future, the database may have grown to contain other object
stores and indexes. The following example shows one way to handle
opening an older version of the database.

<pre class=lang-javascript>
var request = indexedDB.open("library", 3); // Request version 3.

request.onupgradeneeded = function(event) {
  var db = request.result;
  if (event.oldVersion &lt; 1) {
    // Version 1 is the first version of the database.
    var store = db.createObjectStore("books", {keyPath: "isbn"});
    var titleIndex = store.createIndex("by_title", "title", {unique: true});
    var authorIndex = store.createIndex("by_author", "author");
  }
  if (event.oldVersion &lt; 2) {
    // Version 2 introduces a new index of books by year.
    var bookStore = request.transaction.objectStore("books");
    var yearIndex = bookStore.createIndex("by_year", "year");
  }
  if (event.oldVersion &lt; 3) {
    // Version 3 introduces a new object store for magazines with two indexes.
    var magazines = db.createObjectStore("magazines");
    var publisherIndex = magazines.createIndex("by_publisher", "publisher");
    var frequencyIndex = magazines.createIndex("by_frequency", "frequency");
  }
};

request.onsuccess = function() {
  db = request.result; // db.version will be 3.
};
</pre>

</aside>

<!--
<dl>
<dt>DOM</dt>
<dd>
The terms, types, and algorithms
<dfn><code>Event</code></dfn>,
<dfn>canceled flag</dfn>,
<dfn><code>EventTarget</code></dfn>,
<dfn>get the parent</dfn>, and
<dfn><code>DOMStringList</code></dfn>
are defined by the DOM Standard [[!WHATWG-DOM]].
</dd>
<dt>File API</dt>
<dd>
The types
<dfn><code>Blob</code></dfn> and
<dfn><code>File</code></dfn>
are defined by the File API [[!FileAPI]].
</dd>
<dt>ECMAScript</dt>
<dd>
The types and grammar productions
<dfn><code>Array</code></dfn>,
<dfn><code>ArrayBuffer</code></dfn>,
<dfn><code>Date</code></dfn>,
<dfn><code>IdentifierName</code></dfn>,
<dfn><code>Number</code></dfn>,
<dfn><code>Object</code></dfn>,
<dfn><code>String</code></dfn>,
<dfn><code>TypeError</code></dfn>, and
<dfn><code>Uint8Array</code></dfn>
are defined by the ECMAScript Language Specification [[!ECMA-262]].
</dd>
<dt>HTML</dt>
<dd>
The terms, types and algorithms
<dfn>document</dfn>,
<dfn><code>Window</code></dfn>,
<dfn><code>EventHandler</code></dfn>,
<dfn><code>ImageData</code></dfn>,
<dfn>worker</dfn>,
<dfn><code>WorkerGlobalScope</code></dfn>,
<dfn>event handler IDL attributes</dfn>,
<dfn>strictly split a string</dfn>,
<dfn data-lt="origins">origin</dfn>, <dfn>same origin</dfn>, <dfn>structured clone</dfn>,
<dfn>structured clone algorithm</dfn>, <dfn>task</dfn>, <dfn>task source</dfn>,
and <dfn>queue a task</dfn>
are defined by the HTML Standard [[!HTML]].
</dd>
<dt>WebIDL</dt>
<dd>
The terms, types, and algorithms
<dfn data-lt="throws|rethrow">throw</dfn>,
<dfn>getting a copy of the bytes held by a buffer source</dfn>,
<dfn data-lt="octets">octet</dfn>,
<dfn>unrestricted double</dfn>,
<dfn>DOMString</dfn>,
<dfn>sequence&lt;DOMString&gt;</dfn>,
<dfn><code>DOMException</code></dfn> and
and the interface definition language used in this spec
are defined by Web IDL [[!WEBIDL]].</dd>
</dl>
-->


<!-- ============================================================ -->
<h2 id=database-api>Indexed Database API</h2>
<!-- ============================================================ -->

A <dfn>sorted list</dfn> is a {{DOMStringList}} containing strings
sorted in ascending order using the algorithm defined by step 4 of
<cite>section 11.8.5, The Abstract Relational Comparison
Algorithm</cite> of the ECMAScript Language Specification
[[!ECMA-262]].

<div class=issue>Make this reference more robust.</div>


<!-- ============================================================ -->
<h3 id=constructs>Constructs</h3>
<!-- ============================================================ -->

<!-- ============================================================ -->
<h4 id=database-concept>Database</h4>
<!-- ============================================================ -->

A database's <a>origin</a> is the same as the <a>origin</a> of the
<a>document</a> or <a>worker</a>. Each <a>origin</a> has an associated
set of databases.

<aside class=note>
  The database origin is not affected by changes to
  <code>document.domain</code>.
</aside>

Each <a>origin</a> has an associated set of <a>databases</a>. A <dfn
data-lt="databases">database</dfn> has zero or more <a>object
stores</a> which hold the data stored in the database.

A <a>database</a> has a <dfn data-lt-noDefault
data-lt="database.name">name</dfn> which identifies it within a
specific <a>origin</a>. The name can be any string value, including
the empty string, and stays constant for the lifetime of the database.
Database names are always compared in a case-sensitive manner, as
opaque sequences of 16-bit code units. Implementations MUST support
all names.

<aside class=note>
  If an implementation uses a storage mechanism which can't handle
  arbitrary database names, the implementation must use an escaping
  mechanism or something similar to map the provided name to a name that
  it can handle.
</aside>

A <a>database</a> has a <dfn>version</dfn>. When a database is first
created, its <a>version</a> is 0 (zero).

<aside class=note>
  Each <a>database</a> has one version at a time; a <a>database</a>
  can't exist in multiple versions at once. The only way to change the
  version is using an <a>upgrade transaction</a>.
</aside>

A database has a <dfn>delete pending flag</dfn> which is used during
deletion. When a database is requested to be deleted the flag is set
and all attempts at opening the database are stalled until the
database can be deleted.

<!-- ============================================================ -->
<h5 id=database-connection>Database Connection</h5>
<!-- ============================================================ -->

Script does not interact with <a>databases</a> directly. Instead,
script has indirect access via a <dfn>connection</dfn>.

A <a>connection</a> object can be used to manipulate the objects of
that <a>database</a>. It is also the only way to obtain a
<a>transaction</a> for that <a>database</a>.

The act of opening a <a>database</a> creates a <a>connection</a>.
There MAY be multiple <a>connections</a> to a given <a>database</a> at
any given time.

A <a>connection</a> has a <dfn data-lt-noDefault
data-lt="connection.version">version</dfn>, which is set when the
<a>connection</a> is created. It remains constant for the lifetime of
the <a>connection</a> unless an <a data-lt="steps for aborting an
upgrade transaction">upgrade is aborted</a>, in which case it is set
to the previous version of the <a>database</a>. Once the
<a>connection</a> is closed the <a
data-lt="connection.version">version</a> does not change.


Each connection has a <dfn>close pending flag</dfn> which is initially
unset.

When a <a>connection</a> is initially created it is in
<dfn>opened</dfn> state. The connection can be <dfn data-lt="database
close">closed</dfn> through several means. If the execution context
where the <a>connection</a> was created is destroyed (for example due
to the user navigating away from that page), the connection is closed.
The connection can also be closed explicitly using the <a>steps for
closing a database connection</a>. When the connection is closed the
<a>close pending flag</a> is always set if it hasn't already been.


A <a>connection</a> may be closed by a user agent in exceptional
circumstances, for example due to loss of access to the file system or
a permission change. If this occurs the user agent MUST run the
<a>steps for closing a database connection</a> with the
<a>connection</a> and with the <var>forced flag</var> set.

A <a>connection</a> has an <dfn>object store set</dfn>, which is
initialized to the set of <a>object stores</a> in the associated
<a>database</a> when the <a>connection</a> is created.

The contents of the set will remain constant except when an <a>upgrade
transaction</a> is running.

A <a>connection</a>'s <a>get the parent</a> algorithm returns null.


<!-- ============================================================ -->
<h4 id=object-store-concept>Object Store</h4>
<!-- ============================================================ -->

An <dfn>object store</dfn> is the primary
storage mechanism for storing data in a <a>database</a>.

Each database has a set of <a>object stores</a>. The set of <a>object
stores</a> can be changed, but only using an <a>upgrade
transaction</a>, i.e. in response to an <a>upgradeneeded</a> event.
When a new database is created it doesn't contain any <a>object
stores</a>.

An <a>object store</a> has a <dfn data-lt-noDefault data-lt="object
store record list">list of records</dfn> which hold the data stored in
the object store. Each <dfn data-lt="records">record</dfn> consists of
a <a>key</a> and a <a>value</a>. The list is sorted according to key
in ascending order. There can never be multiple records in a given
object store with the same key.

An <a>object store</a> has a <dfn data-lt-noDefault
data-lt="objectStore.name">name</dfn>. The name can be any string
value, including the empty string. At any one time, the name is unique
within the <a>database</a> to which it belongs. Object store names are
always compared in a case-sensitive manner, as opaque sequences of
16-bit code units.

An <a>object store</a> optionally has a <dfn data-lt-noDefault
data-lt="objectStore.keyPath">key path</dfn>. If the object store has
a key path it is said to use <dfn>in-line keys</dfn>. Otherwise it is
said to use <dfn>out-of-line keys</dfn>.

An <a>object store</a> optionally has a <a>key generator</a>.

An object store can derive a <a>key</a> for a <a>record</a> from one of three sources:

1. A <a>key generator</a>. A key generator generates a monotonically
    increasing numbers every time a key is needed.

2. Keys can be derived via a <a data-lt="objectStore.keyPath">key path</a>.

3. Keys can also be explicitly specified when a <a>value</a> is stored
    in the object store.

<!-- ============================================================ -->
<h5 id=concept-object-store-handle>Object Store Handle</h5>
<!-- ============================================================ -->

Script does not interact with <a>object stores</a> directly. Instead,
within a <a>transaction</a>, script has indirect access via an
<dfn>object store handle</dfn>.

An <a>object store handle</a> has an associated <dfn data-lt-noDefault
data-lt="objectStoreHandle.objectStore">object store</dfn> and an
associated <dfn data-lt-noDefault
data-lt="objectStoreHandle.transaction">transaction</dfn>. Multiple
handles MAY be associated with the same <a>object store</a> in
different <a>transactions</a>, but there MUST be only one <a>object
store handle</a> associated with a particular <a>object store</a>
within a <a>transaction</a>.

An <a>object store handle</a> has an <dfn>index set</dfn>, which is
initialized to the set of <a>indexes</a> that reference the associated
<a data-lt="objectStoreHandle.objectStore">object store</a> when the
<a>object store handle</a> is created.

The contents of the set will remain constant except when an <a>upgrade
transaction</a> is running.

An <a>object store handle</a> has a <dfn data-lt-noDefault
data-lt="objectStoreHandle.name">name</dfn>, which is initialized to
the <a data-lt="objectStore.name">name</a> of the associated <a
data-lt="objectStoreHandle.objectStore">object store</a> when the
<a>object store handle</a> is created.

The name will remain constant except when an <a>upgrade
transaction</a> is running.


<!-- ============================================================ -->
<h4 id=value-construct>Values</h4>
<!-- ============================================================ -->

Each record is associated with a <dfn data-lt="values">value</dfn>.
User agents MUST support any ECMAScript [[!ECMA-262]] value supported
by the <a>structured clone algorithm</a> [[!HTML]]. This includes
simple types such as <a>String</a> primitive values and <a>Date</a>
objects as well as <a>Object</a> and <a>Array</a> instances, {{File}}
objects, {{Blob}} objects, {{ImageData}}} objects, and so on. Record
<a>values</a> are stored and retrieved by value rather than by
reference; later changes to a value have no effect on the record
stored in the database.


<!-- ============================================================ -->
<h4 id=key-construct>Keys</h4>
<!-- ============================================================ -->

In order to efficiently retrieve <a>records</a> stored in an indexed
database, each <a>record</a> is organized according to its <dfn
data-lt="keys">key</dfn>.

A <a>key</a> has an associated <dfn data-lt="key.type">type</dfn> which is one of:
<i>number</i>,
<i>date</i>,
<i>string</i>,
<i>binary</i>,
or
<i>array</i>.

<aside class=note>&#9752; Support for <i>binary</i> keys is new in this edition. &#9752;</aside>

A <a>key</a> also has an associated <dfn data-lt-noDefault data-lt="key.value">value</dfn>, which will
be either:
an <a>unrestricted double</a> if type is <i>number</i> or <i>date</i>,
a <a>DOMString</a> if type is <i>string</i>,
a list of <a>octets</a> if type is <i>binary</i>,
or a list of other <a>keys</a> if type is <i>array</i>.


An ECMAScript [[!ECMA-262]] value can be converted to a <a>key</a> by
following the steps to <a>convert a value to a key</a>.

<aside class=note>
The following ECMAScript types are valid keys:

* <a>Number</a> primitive values, except NaN. This includes Infinity and -Infinity.
* <a>Date</a> objects, except where the [<span>[</span>DateValue]] internal slot is NaN
* <a>String</a> primitive values.
* {{ArrayBuffer}} objects (or views on buffers such as <a>Uint8Array</a>).
* <a>Array</a> objects, where every item is defined, is itself a valid key, and does not directly or indirectly contain itself. This includes empty arrays. Arrays may contain other arrays.

Attempting to convert other ECMAScript values to a <a>key</a> will fail.
</aside>

An <dfn data-lt="array keys">array key</dfn> is a <a>key</a> with <a
data-lt="key.type">type</a> <i>array</i>. The <dfn>subkeys</dfn> of an
<a>array key</a> are the members of the <a>array key</a>'s <a
data-lt="key.value">value</a> list.

To <dfn>compare two keys</dfn> <var>a</var> and <var>b</var>, run these steps:


1. Let <var>ta</var> be the <a data-lt="key.type">type</a> of <var>a</var>.

2. Let <var>tb</var> be the <a data-lt="key.type">type</a> of <var>b</var>.

3. If <var>ta</var> is <i>array</i> and <var>tb</var> is
    <i>binary</i>, <i>string</i>, <i>date</i> or <i>number</i>,
    return 1.
4. If <var>tb</var> is <i>array</i> and <var>ta</var> is
    <i>binary</i>, <i>string</i>, <i>date</i> or <i>number</i>,
    return -1.

5. If <var>ta</var> is <i>binary</i> and <var>tb</var> is
    <i>string</i>, <i>date</i> or <i>number</i>,
    return 1.
6. If <var>tb</var> is <i>binary</i> and <var>ta</var> is
    <i>string</i>, <i>date</i> or <i>number</i>,
    return -1.

7. If <var>ta</var> is <i>string</i> and <var>tb</var> is
    <i>date</i> or <i>number</i>,
    return 1.
8. If <var>tb</var> is <i>string</i> and <var>ta</var> is
    <i>date</i> or <i>number</i>,
    return -1.

9. If <var>ta</var> is <i>date</i> and <var>tb</var> is
    <i>number</i>,
    return 1.
10. If <var>tb</var> is <i>date</i> and <var>ta</var> is
    <i>number</i>,
    return -1.

11. Assert: <var>ta</var> and <var>tb</var> are equal.

12. Let <var>va</var> be the <a data-lt="key.value">value</a> of <var>a</var>.
13. Let <var>vb</var> be the <a data-lt="key.value">value</a> of <var>b</var>.

14. Switch on <var>ta</var>:

    <dl class=switch>
      <dt><i>number</i></dt>
      <dt><i>date</i></dt>
      <dd>
        1. If <var>va</var> is greater than <var>vb</var>, then return 1.
        2. If <var>va</var> is less than <var>vb</var>, then return -1.
        3. Return 0
      </dd>

      <dt><i>string</i></dt>
      <dd>
        1. Let <var>length</var> be the lesser of <var>va</var>'s length and <var>vb</var>'s length.
        2. Let <var>i</var> be 0.
        3. While <var>i</var> is less than <var>length</var>, run these substeps:
            1. Let <var>u</var> be the code unit of <var>va</var> at index <var>i</var>
            2. Let <var>v</var> be the code unit of <var>vb</var> at index <var>i</var>
            3. If <var>u</var> is greater than <var>v</var> then return 1
            4. If <var>u</var> is less than <var>v</var> then return -1
            5. Increase <var>i</var> by 1
        4. If <var>va</var>'s length is greater than <var>vb</var>'s length, then return 1
        5. If <var>va</var>'s length is less than <var>vb</var>'s length, then return -1
        6. Return 0
      </dd>

      <dt><i>binary</i></dt>
      <dd>
        1. Let <var>length</var> be the lesser of <var>va</var>'s length and <var>vb</var>'s length.
        2. Let <var>i</var> be 0.
        3. While <var>i</var> is less than <var>length</var>, run these substeps:

            1. Let <var>u</var> be the <a>octet</a> in <var>va</var> at index <var>i</var>
            2. Let <var>v</var> be the <a>octet</a> in <var>vb</var> at index <var>i</var>
            3. If <var>u</var> is greater than <var>v</var> then return 1
            4. If <var>u</var> is less than <var>v</var> then return -1
            5. Increase <var>i</var> by 1

        4. If <var>va</var>'s length is greater than <var>vb</var>'s length, then return 1
        5. If <var>va</var>'s length is less than <var>vb</var>'s length, then return -1
        6. Return 0
      </dd>

      <dt><i>array</i></dt>
      <dd>
        1. Let <var>length</var> be the lesser of <var>va</var>'s length and <var>vb</var>'s length.
        2. Let <var>i</var> be 0.
        3. While <var>i</var> is less than <var>length</var>, run these substeps:

            1. Let <var>u</var> be the <a>key</a> in <var>va</var> at index <var>i</var>
            2. Let <var>v</var> be the <a>key</a> in <var>vb</var> at index <var>i</var>
            3. Let <var>c</var> be the result of recursively running the steps to <a>compare two keys</a> with <var>u</var> and <var>v</var>
            4. If <var>c</var> is not 0, return <var>c</var>
            5. Increase <var>i</var> by 1

        4. If <var>va</var>'s length is greater than <var>vb</var>'s length, then return 1
        5. If <var>va</var>'s length is less than <var>vb</var>'s length, then return -1
        6. Return 0
      </dd>
    </dl>

The <a>key</a> <var>a</var> is <dfn>greater than</dfn> the <a>key</a>
<var>b</var> if the result of running the steps to <a>compare two
keys</a> with <var>a</var> and <var>b</var> is 1.

The <a>key</a> <var>a</var> is <dfn>less than</dfn> the <a>key</a>
<var>b</var> if the result of running the steps to <a>compare two
keys</a> with <var>a</var> and <var>b</var> is -1.

The <a>key</a> <var>a</var> is <dfn>equal to</dfn> the <a>key</a>
<var>b</var> if the result of running the steps to <a>compare two
keys</a> with <var>a</var> and <var>b</var> is 0.


<aside class=note>
As a result of the above rules, negative infinity is the lowest possible value for a <a>key</a>.
<i>Number</i> keys are less than <i>date</i> keys.
<i>Date</i> keys are less than <i>string</i> keys.
<i>String</i> keys are less than <i>binary</i> keys.
<i>Binary</i> keys are less than <i>array</i> keys.
There is no highest possible <a>key</a> value.
This is because an array of any candidate highest <a>key</a> followed by another <a>key</a> is even higher.
</aside>

<aside class=note>
Members of <i>binary</i> keys are compared as unsigned octet values
(in the range [0, 255]) rather than signed bytes (in the range [-128,
127]).
</aside>


<!-- ============================================================ -->
<h4 id=key-path-construct>Key Path</h4>
<!-- ============================================================ -->

A <dfn data-lt="key paths">key path</dfn> is a <a>DOMString</a> or
<a>sequence&lt;DOMString&gt;</a> that defines how to extract a
<a>key</a> from a <a>value</a>. A <dfn>valid key path</dfn> is one of:

* An empty <a>DOMString</a>.
* An <dfn data-lt="identifiers">identifier</dfn>, which is a <a>DOMString</a> matching
    the <a>IdentifierName</a> production from the ECMAScript Language Specification [[!ECMA-262]].
* A <a>DOMString</a> consisting of two or more <a>identifiers</a> separated by
    periods (ASCII character code 46, U+002E FULL STOP).
* A non-empty <a>sequence&lt;DOMString&gt;</a> containing only strings conforming to
    the above requirements.

<aside class=note>
Spaces are not allowed within a key path.
</aside>

<a>Key path</a> values can only be accessed from properties explicitly
copied by the <a>structured clone algorithm</a>, as well as the
following type-specific properties:

<table>
  <tr><th>Type</th><th>Properties</th></tr>
  <tr><td>{{Blob}}</td><td><code>size</code>, <code>type</code></td></tr>
  <tr><td>{{File}}</td><td><code>name</code>, <code>lastModified</code>, <code>lastModifiedDate</code></td></tr>
  <tr><td><a>Array</a></td><td><code>length</code></td></tr>
  <tr><td><a>String</a></td><td><code>length</code></td></tr>
</table>


<!-- ============================================================ -->
<h4 id=index-concept>Index</h4>
<!-- ============================================================ -->

It is sometimes useful to retrieve <a>records</a> in an <a>object
store</a> through other means than their <a>key</a>. An <dfn
data-lt="indexes">index</dfn> allows looking up <a>records</a> in an
<a>object store</a> using properties of the <a>values</a> in the
<a>object stores</a> <a>records</a>.

An index is a specialized persistent key-value storage and has a <dfn
data-lt="reference|references">referenced</dfn> <a>object store</a>.
The index has a <dfn data-lt-noDefault data-lt="index record
list">list of records</dfn> which hold the data stored in the index.
The records in an index are automatically populated whenever records
in the <a>referenced</a> object store are inserted, updated or
deleted. There can be several <a>indexes</a> referencing the same
<a>object store</a>, in which changes to the object store cause all
such indexes to get updated.

The values in the index's <a>records</a> are always values of
<a>keys</a> in the index's <a>referenced</a> object store. The keys
are derived from the referenced object store's <a>values</a> using a
<dfn data-lt-noDefault data-lt="index.keyPath">key path</dfn>. If a
given <a>record</a> with key <var>X</var> in the object store
referenced by the index has the value <var>A</var>, and <a
data-lt="extract a key from a value using a key path">evaluating</a>
the <a data-lt="index.keyPath">index's key path</a> on <var>A</var>
yields the result <var>Y</var>, then the index will contain a record
with key <var>Y</var> and value <var>X</var>.

<aside class=example>
For example, if an index's <a>referenced</a> object store contains a
record with the key <code>123</code> and the value <code>{ first:
"Alice", last: "Smith" }</code>, and the <a
data-lt="index.keyPath">index's key path</a> is "<code>first</code>"
then the index would contain a record with the key
"<code>Alice</code>" and the value <code>123</code>.
</aside>

Records in an index are said to have a <dfn>referenced value</dfn>.
This is the value of the record in the index's referenced object store
which has a key equal to the index's record's value. So in the example
above, the record in the index whose key is <var>Y</var> and value is
<var>X</var> has a <a>referenced value</a> of <var>A</var>.

<aside class=example>
In the preceding example, the record in the index with key
"<code>Alice</code>" and value <code>123</code> would have a
<a>referenced value</a> of <code>{ first: "Alice", last: "Smith"
}</code>.
</aside>

<aside class=note>
Each record in an index references one and only one record in the
index's <a>referenced</a> object store. However there can be multiple
records in an index which reference the same record in the object
store. And there can also be no records in an index which reference a
given record in an object store.
</aside>

The <a>records</a> in an index are always sorted according to the
<a>record</a>'s key. However unlike object stores, a given index can
contain multiple records with the same key. Such records are
additionally sorted according to the <a>index</a>'s <a>record</a>'s
value (meaning the key of the record in the referenced <a>object
store</a>).

An <a>index</a> has a <dfn data-lt-noDefault
data-lt="index.name">name</dfn>. The name can be any string value,
including the empty string. At any one time, the name is unique within
index's <a>referenced</a> <a>object store</a>. Index names are always
compared in a case-sensitive manner, as opaque sequences of 16-bit
code units.

An <a>index</a> has a <dfn>unique flag</dfn>. When this flag is set,
the index enforces that no two <a>records</a> in the index has the
same key. If a <a>record</a> in the index's referenced object store is
attempted to be inserted or modified such that evaluating the index's
key path on the records new value yields a result which already exists
in the index, then the attempted modification to the object store
fails.

An <a>index</a> has a <dfn>multiEntry flag</dfn>. This flag affects
how the index behaves when the result of evaluating the index's <a
data-lt="index.keyPath">key path</a> yields an <a>array key</a>. If
the <a>multiEntry flag</a> is unset, then a single <a>record</a> whose
<a>key</a> is an <a>array key</a> is added to the index. If the
<a>multiEntry flag</a> is true, then the one <a>record</a> is added to
the index for each of the <a>subkeys</a>.


<!-- ============================================================ -->
<h5 id=concept-index-handle>Index Handle</h5>
<!-- ============================================================ -->

Script does not interact with <a>indexes</a> directly. Instead, within
a <a>transaction</a>, script has indirect access via an <dfn>index
handle</dfn>.

An <a>index handle</a> has an associated <dfn data-lt-noDefault
data-lt="indexHandle.index">index</dfn> and an associated <dfn
data-lt-noDefault data-lt="indexHandle.objectStoreHandle">object store
handle</dfn>. The <dfn data-lt-noDefault
data-lt="indexHandle.transaction">transaction</dfn> of an <a>index
handle</a> is the <a
data-lt="objectStoreHandle.transaction">transaction</a> of its
associated <a>object store handle</a>. Multiple handles MAY be
associated with the same <a>index</a> in different
<a>transactions</a>, but there MUST be only one <a>index handle</a>
associated with a particular <a>index</a> within a <a>transaction</a>.

An <a>index handle</a> has a <dfn data-lt-noDefault
data-lt="indexHandle.name">name</dfn>, which is initialized to the <a
data-lt="index.name">name</a> of the associated <a
data-lt="indexHandle.index">index</a> when the <a>index handle</a> is
created.

The name will remain constant except when an <a>upgrade
transaction</a> is running.


<!-- ============================================================ -->
<h4 id=transaction-concept>Transactions</h4>
<!-- ============================================================ -->

A <dfn data-lt="transactions">Transaction</dfn> is used to interact
with the data in a <a>database</a>. Whenever data is read or written
to the database it is done by using a <a>transaction</a>.

<a>transactions</a> offer some protection from application and system
failures. A <a>transaction</a> may be used to store multiple data
records or to conditionally modify certain data records. A
<a>transaction</a> represents an atomic and durable set of data access
and data mutation operations.

All transactions are created through a <a>connection</a>, which is the
transaction's <dfn data-lt-noDefault
data-lt="transaction.connection">connection</dfn>.

A <a>transaction</a> has a <dfn data-lt="scopes">scope</dfn> that
determines the <a>object stores</a> with which the transaction may
interact. A transaction's scope remains fixed for the lifetime of that
transaction.

A <a>transaction</a> has a <dfn data-lt="modes">mode</dfn> that
determines which types of interactions can be performed upon that
transaction. The <a>mode</a> is set when the transaction is created
and remains fixed for the life of the transaction. A
<a>transaction</a>'s <a>mode</a> is one of the following:

<dl>
  <dt>"<code>readonly</code>"</dt>
  <dd>
    The transaction is only allowed to read data. No modifications can
    be done by this type of transaction. This has the advantage that
    several <a>read-only transactions</a> can run at the same time
    even if their <a>scopes</a> are overlapping, i.e. if they are
    using the same object stores. This type of transaction can be
    created any time once a database has been opened.
  </dd>

  <dt>"<code>readwrite</code>"</dt>
  <dd>
    The transaction is allowed to read, modify and delete data from
    existing object stores. However object stores and indexes can't be
    added or removed. Multiple "<code>readwrite</code>" transactions
    can't run at the same time if their <a>scopes</a> are overlapping
    since that would mean that they can modify each other's data in
    the middle of the transaction. This type of transaction can be
    created any time once a database has been opened.
  </dd>

  <dt>"<code>versionchange</code>"</dt>
  <dd>
    The transaction is allowed to read, modify and delete data from
    existing object stores, and can also create and remove object
    stores and indexes. It is the only type of transaction that can do
    so. This type of transaction can't be manually created, but
    instead is created automatically when an <a>upgradeneeded</a>
    event is fired.
  </dd>
</dl>

A <a>transaction</a> has an <dfn>active flag</dfn>, which determines
if new <a>requests</a> can be made against the transaction. A
transaction is said to be <dfn>active</dfn> if its <a>active flag</a>
is set.

A <a>transaction</a> has a <dfn>request list</dfn> of <a>requests</a>
which have been made against the transaction.

A <a>transaction</a> has a <dfn data-lt-noDefault data-lt="transaction
error">error</dfn> which is set if the <a>transaction</a> is <a
data-lt="transaction abort">aborted</a>.

A <a>transaction</a>'s <a>get the parent</a> algorithm returns the
transaction's <a data-lt="transaction.connection">connection</a>.

Transactions are expected to be short lived. This is encouraged by the
<a data-lt="transaction commit">automatic committing</a> functionality
described below.

<aside class=note>
Authors can still cause transactions to run for a long time; however,
this usage pattern is not generally recommended as it can lead to a
bad user experience.
</aside>

The <dfn data-lt="transaction lifetime">lifetime</dfn> of a
<a>transaction</a> is as follows:

1. A transaction is <dfn data-lt="transaction create">created</dfn> with a <a>scope</a> and a <a>mode</a>.
    When a transaction is created its <a>active flag</a> is initially set.

2. The implementation MUST allow <a>requests</a> to be <a
    data-lt="place request">placed</a> against the transaction
    whenever the <a>active flag</a> is set. This is the case even if
    the transaction has not yet been <a data-lt="transaction
    start">started</a>. Until the transaction is <a
    data-lt="transaction start">started</a> the implementation MUST
    NOT execute these requests; however, the implementation MUST keep
    track of the <a>requests</a> and their order. Requests may be
    placed against a transaction only while that transaction is
    <a>active</a>. If an attempt is made to place a request against a
    transaction when that transaction is not <a>active</a>, the
    implementation MUST reject the attempt by throwing a
    <a>TransactionInactiveError</a> exception.

3. Once an implementation is able to enforce the constraints defined
    for the transaction <a>scope</a> and <a>mode</a>, defined below,
    the implementation MUST <a>queue a task</a> to <dfn
    data-lt="transaction start">start</dfn> the transaction
    asynchronously.

4. Once the transaction has been <a data-lt="transaction
    start">started</a> the implementation can start executing the
    <a>requests</a> placed against the transaction. Unless otherwise
    defined, requests MUST be executed in the order in which they were
    made against the transaction. Likewise, their results MUST be
    returned in the order the requests were placed against a specific
    transaction. There is no guarantee about the order that results
    from requests in different transactions are returned. Similarly,
    the transaction <a>modes</a> ensure that two requests placed
    against different transactions can execute in any order without
    affecting what resulting data is stored in the database.

5. A transaction can be <dfn data-lt="transaction abort">aborted</dfn>
    at any time before it is <a data-lt="transaction
    finish">finished</a>, even if the transaction isn't currently
    <a>active</a> or hasn't yet <a data-lt="transaction
    start">started</a>. When a transaction is aborted the
    implementation MUST undo (roll back) any changes that were made to
    the <a>database</a> during that transaction. This includes both
    changes to the contents of <a>object stores</a> as well as
    additions and removals of <a>object stores</a> and <a>indexes</a>.

6. A transaction can fail for reasons not tied to a particular
    <a>request</a>. For example due to IO errors when committing the
    transaction, or due to running into a quota limit where the
    implementation can't tie exceeding the quota to a partcular
    request. In this case the implementation MUST run the <a>steps for
    aborting a transaction</a> using the transaction as
    <var>transaction</var> and the appropriate error type as
    <var>error</var>. For example if quota was exceeded then
    <a>QuotaExceededError</a> should be used as <var>error</var>, and
    if an IO error happened, <a>UnknownError</a> should be used as
    <var>error</var>.

7. When a transaction can no longer become <a>active</a>, the
    implementation MUST attempt to <dfn data-lt="transaction
    commit">commit</dfn> it, as long as the transaction has not been
    <a data-lt="transaction abort">aborted</a>. This usually happens
    after all requests placed against the transaction have been
    executed and their returned results handled, and no new requests
    have been placed against the transaction. When a transaction is
    committed, the implementation MUST atomically write any changes to
    the <a>database</a> made by requests placed against the
    transaction. That is, either all of the changes MUST be written,
    or if an error occurs, such as a disk write error, the
    implementation MUST NOT write any of the changes to the database.
    If such an error occurs, the implementation MUST <a
    data-lt="transaction abort">abort</a> the transaction by following
    the <a>steps for aborting a transaction</a>, otherwise it MUST <a
    data-lt="transaction commit">commit</a> the transaction by
    following the <a>steps for committing a transaction</a>.

8. When a transaction is <a data-lt="transaction commit">committed</a>
    or <a data-lt="transaction abort">aborted</a>, it is said to be
    <dfn data-lt="transaction finish">finished</dfn>. If a transaction
    can't be finished, for example due to the implementation crashing
    or the user taking some explicit action to cancel it, the
    implementation MUST <a data-lt="transaction abort">abort</a> the
    transaction.

A <dfn data-lt="read-only transactions">read-only transaction</dfn> is
a <a>transaction</a> with <a>mode</a> "<code>readonly</code>".

A <dfn data-lt="read/write transactions">read/write transaction</dfn>
is a <a>transaction</a> with <a>mode</a> "<code>readwrite</code>".

The following constraints define when a <a>transaction</a> can be <a
data-lt="transaction start">started</a>:

* Any number of <a>read-only transactions</a> are allowed to run
    concurrently, even if the transaction's <a>scope</a> overlap and
    include the same <a>object stores</a>. As long as a <a>read-only
    transaction</a> is running, the data that the implementation
    returns through <a>requests</a> created with that transaction MUST
    remain constant. That is, two requests to read the same piece of
    data MUST yield the same result both for the case when data is
    found and the result is that data, and for the case when data is
    not found and a lack of data is indicated.

    <aside class=note>
      There are a number of ways that an implementation can ensure
      this. The implementation could prevent any <a>read/write
      transaction</a>, whose scope overlaps the scope of the
      <a>read-only transaction</a>, from starting until the
      <a>read-only transaction</a> finishes. Or the implementation
      could allow the <a>read-only transaction</a> to see a snapshot
      of the contents of the <a>object stores</a> which is taken when
      the <a>read-only transaction</a> started.
    </aside>

* Similarly, implementations MUST ensure that a <a>read/write
    transaction</a> is only affected by changes to <a>object
    stores</a> that are made using the transaction itself. For
    example, the implementation MUST ensure that another transaction
    does not modify the contents of <a>object stores</a> in the
    <a>read/write transaction</a>'s <a>scope</a>. The implementation
    MUST also ensure that if the <a>read/write transaction</a>
    completes successfully, the changes written to <a>object
    stores</a> using the transaction can be committed to the
    <a>database</a> without merge conflicts. An implementation MUST
    NOT abort a transaction due to merge conflicts.

* If multiple <a>read/write transactions</a> are attempting to access
    the same object store (i.e. if they have overlapping
    <a>scope</a>), the transaction that was <a data-lt="transaction
    create"> created</a> first MUST be the transaction which gets
    access to the object store first. Due to the requirements in the
    previous paragraph, this also means that it is the only
    transaction which has access to the object store until the
    transaction is <a data-lt="transaction finish">finished</a>.

* Any transaction <a data-lt="transaction create">created</a> after a
    <a>read/write transaction</a> MUST see the changes written by the
    <a>read/write transaction</a>. So if a <a>read/write
    transaction</a>, A, is created, and later another transaction B,
    is created, and the two transactions have overlapping
    <a>scopes</a>, then B MUST see any changes made to any <a>object
    stores</a> that are part of that overlapping <a>scope</a>. Due to
    the requirements in the previous paragraph, this also means that
    the B transaction does not have access to any <a>object stores</a>
    in that overlapping <a>scope</a> until the A transaction is <a
    data-lt="transaction finish">finished</a>.

    <aside class=note>
      Generally speaking, the above requirements mean that any
      transaction which has an overlapping scope with a <a>read/write
      transaction</a> and which was created after that <a>read/write
      transaction</a>, can't run in parallel with that <a>read/write
      transaction</a>.
    </aside>

* User agents MUST ensure a reasonable level of fairness across
    transactions to prevent starvation. For example, if multiple
    <a>read-only transactions</a> are started one after another the
    implementation MUST NOT indefinitely prevent a pending
    <a>read/write transaction</a> from <a data-lt="transaction
    start">starting</a>.


<!-- ============================================================ -->
<h5 id=upgrade-transaction>Upgrade Transactions</h5>
<!-- ============================================================ -->

An <dfn data-lt="upgrade transactions">upgrade transaction</dfn> is a
<a>transaction</a> with <a>mode</a> "<code>versionchange</code>".

An <a>upgrade transaction</a> is automatically created when running
<a>steps for running an upgrade transaction</a> after a
<a>connection</a> is opened to a <a>database</a> giving a greater
<a>version</a> than the current <a>version</a>. This
<a>transaction</a> will be active inside the <a>upgradeneeded</a>
event handler, allowing the creation of new <a>object stores</a> and
<a>indexes</a>.

An <a>upgrade transaction</a> is never run concurrently with other
transactions. When a database is opened with a <a>version</a> number
higher than the current <a>version</a>, a new <a>upgrade
transaction</a> is automatically created and made available through
the <a>open request</a> when the <a>upgradeneeded</a> event is fired.
The <a>upgradeneeded</a> event isn't fired, and thus the <a>upgrade
transaction</a> isn't started, until all other <a>connections</a> to
the same <a>database</a> are closed. This ensures that all other
transactions are <a data-lt="transaction finish">finished</a>.

As long as an <a>upgrade transaction</a> is running, attempts to open
more <a>connections</a> to the same <a>database</a> are delayed, and
any attempts to use the same <a>connection</a> to start additional
transactions will result in an exception being thrown. Thus <a>upgrade
transactions</a> not only ensure that no other transactions are
running concurrently, but also ensure that no other transactions are
queued against the same <a>database</a> as long as the transaction is
running.


<!-- ============================================================ -->
<h4 id=request-concept>Requests</h4>
<!-- ============================================================ -->

Each asynchronous operation on a <a>database</a> is done using a <dfn
data-lt="requests">request</dfn>. Every request represents one
operation.

A <a>request</a> has a <dfn>done flag</dfn> which is initially unset.

A <a>request</a> has a <dfn data-lt-noDefault
data-lt="request.source">source</dfn> object.

A <a>request</a> has a <dfn data-lt="request.result">result</dfn> and
an <dfn data-lt-noDefault data-lt="request.error">error</dfn>, neither
of which are accessible until the <a>done flag</a> is set.

A <a>request</a> has a <dfn data-lt-noDefault
data-lt="request.transaction">transaction</dfn> which is initially
null. This will be set when a request is <dfn data-lt="place
request">placed</dfn> against a <a>transaction</a> using the <a>steps
for asynchronously executing a request</a>.

When a request is made, a new <a>request</a> is returned with its
<a>done flag</a> unset. If a request completes successfully, the
<a>done flag</a> is set, the <a data-lt="request.result">result</a> is
set to the result of the request, and an event with type
<code>success</code> is fired at the <a>request</a>.

If an error occurs while performing the operation, the <a>done
flag</a> is set, the <a data-lt="request.error">error</a> is set to
the error, and an event with type <code>error</code> is fired at the
request.

A <a>request</a>'s <a>get the parent</a> algorithm
returns the request's <a data-lt="request.transaction">transaction</a>.

An <dfn>open request</dfn> is a special type of <a>request</a> used
when opening a <a>connection</a> or deleting a <a>database</a>. In
addition to <code>success</code> and <code>error</code> events,
<a>blocked</a> and <a>upgradeneeded</a> may be fired at an <a>open
request</a> to indicate progress.

The <a data-lt="request.source">source</a> of an <a>open request</a>
is always null.

The <a data-lt="request.transaction">transaction</a> of an <a>open
request</a> is null unless an <a>upgradeneeded</a> event has been
fired.

An <a>open request</a>'s <a>get the parent</a> algorithm returns null.

<aside class=note>
  Requests are not typically re-used, but there are exceptions. When a
  <a>cursor</a> is iterated, the success of the iteration is reported
  on the same <a>request</a> object used to open the cursor. And when
  an <a>upgrade transaction</a> is necessary, the same <a>open
  request</a> is used for both the <a>upgradeneeded</a> event and
  final result of the open operation itself. In both cases, the
  request's <a>done flag</a> will be unset then set again, and the <a
  data-lt="request.result">result</a> may change.
</aside>



<!-- ============================================================ -->
<h4 id=range-concept>Key Range</h4>
<!-- ============================================================ -->

Records can be retrieved from <a>object stores</a> and <a>indexes</a>
using either <a>keys</a> or <a>key ranges</a>. A <dfn data-lt="key
ranges">key range</dfn> is a continuous interval over some data type
used for keys.

A <a>key range</a> has an associated <dfn>lower bound</dfn> (null or a
<a>key</a>).

A <a>key range</a> has an associated <dfn>upper bound</dfn> (null or a
<a>key</a>).

A <a>key range</a> has an associated <dfn>lower open flag</dfn>.
Unless otherwise stated it is unset.

A <a>key range</a> has an associated <dfn>upper open flag</dfn>.
Unless otherwise stated it is unset.

A <a>key range</a> MAY have a <a>lower bound</a> <a>equal to</a> its
<a>upper bound</a>. A <a>key range</a> MUST NOT have a <a>lower
bound</a> <a>greater than</a> its <a>upper bound</a>.

A <a>key range</a> <dfn>containing only</dfn> <var>key</var> has both
<a>lower bound</a> and <a>upper bound</a> equal to <var>key</var>.

A <var>key</var> is <dfn>in a key range</dfn> if both of the following
conditions are fulfilled:

* The <a>lower bound</a> is null, or it is <a>less than</a>
    <var>key</var>, or it is both <a>equal to</a> <var>key</var> and
    the <a>lower open flag</a> is unset.

* The <a>upper bound</a> is null, or it is <a>greater than</a>
    <var>key</var>, or it is both <a>equal to</a> <var>key</var> and
    the <a>upper open flag</a> is unset.

<aside class=note>

  * If the <a>lower open flag</a> of a <a>key range</a> is unset, the
    <a>lower bound</a> <a>key</a> of the <a>key range</a> is included
    in the range itself.

  * If the <a>lower open flag</a> of a <a>key range</a> is set, the
    <a>lower bound</a> <a>key</a> of the <a>key range</a> is excluded
    from the range itself.

  * If the <a>upper open flag</a> of a <a>key range</a> is unset, the
    <a>upper bound</a> <a>key</a> of the <a>key range</a> is included
    in the range itself.

  * If the <a>upper open flag</a> of a <a>key range</a> is set, the
    <a>upper bound</a> <a>key</a> of the <a>key range</a> is excluded
    from the range itself.

</aside>

An <dfn>unbounded key range</dfn> is a <a>key range</a> that has both
<a>lower bound</a> and <a>upper bound</a> equal to null. All
<a>keys</a> are <a data-lt="in a key range">in</a> an <a>unbounded key
range</a>.

The steps to <dfn>convert a value to a key range</dfn> with
<var>value</var> and optional <var>null disallowed flag</var> are as
follows:

1. If <var>value</var> is a <a>key range</a>, return <var>value</var>.

2. If <var>value</var> is undefined or is null, then <a>throw</a> a
    <a>DataError</a> exception if <var>null disallowed flag</var> is
    set, or return an <a>unbounded key range</a> otherwise.

3. Let <var>key</var> be the result of running the steps to <a>convert
    a value to a key</a> with <var>value</var>. If this throws an
    exception, <a>rethrow</a> it.

4. If <var>key</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

5. Return a <a>key range</a> <a>containing only</a> <var>key</var>.


<!-- ============================================================ -->
<h4 id=cursor-concept>Cursor</h4>
<!-- ============================================================ -->

A <dfn>cursor</dfn> is used to iterate over a range of records in an
<a>index</a> or an <a>object store</a> in a specific direction.

A <a>cursor</a> has a <dfn data-lt-noDefault
data-lt="cursor.transaction">transaction</dfn>, the <a>transaction</a>
that was <a>active</a> when the cursor was created.

A <a>cursor</a> has a <dfn>range</dfn> of records in either an
<a>index</a> or an <a>object store</a>.

A <a>cursor</a> has a <dfn data-lt-noDefault
data-lt="cursor.source">source</dfn> that indicates which <a>index</a>
or an <a>object store</a> is associated with the records over which
the <a>cursor</a> is iterating.

A <a>cursor</a> has a <dfn>direction</dfn> that determines whether it
moves in monotonically increasing or decreasing order of the
<a>record</a> keys when iterated, and if it skips duplicated values
when iterating indexes. The direction of a cursor also determines if
the cursor initial position is at the start of its <a
data-lt="cursor.source">source</a> or at its end. A cursor's
<a>direction</a> is one of the following:


<dl>
  <dt>"<code>next</code>"</dt>
  <dd>
    This direction causes the cursor to be opened at the start of the
    <a data-lt="cursor.source">source</a>. When iterated, the
    <a>cursor</a> should yield all records, including duplicates, in
    monotonically increasing order of keys.
  </dd>

  <dt>"<code>nextunique</code>"</dt>
  <dd>
    This direction causes the cursor to be opened at the start of the
    <a data-lt="cursor.source">source</a>. When iterated, the
    <a>cursor</a> should not yield records with the same key, but
    otherwise yield all records, in monotonically increasing order of
    keys. For every key with duplicate values, only the first record
    is yielded. When the <a data-lt="cursor.source">source</a> is an
    <a>object store</a> or an <a>index</a> with the <a>unique flag</a>
    set, this direction has exactly the same behavior as
    "<code>next</code>".
  </dd>

  <dt>"<code>prev</code>"</dt>
  <dd>
    This direction causes the cursor to be opened at the end of the <a
    data-lt="cursor.source">source</a>. When iterated, the
    <a>cursor</a> should yield all records, including duplicates, in
    monotonically decreasing order of keys.
  </dd>

  <dt>"<code>prevunique</code>"</dt>
  <dd>
    This direction causes the cursor to be opened at the end of the <a
    data-lt="cursor.source">source</a>. When iterated, the
    <a>cursor</a> should not yield records with the same key, but
    otherwise yield all records, in monotonically decreasing order of
    keys. For every key with duplicate values, only the first record
    is yielded. When the <a data-lt="cursor.source">source</a> is an
    <a>object store</a> or an <a>index</a> with the <a>unique flag</a>
    set, this direction has exactly the same behavior as
    "<code>prev</code>".
  </dd>
</dl>

A <a>cursor</a> has a <dfn>position</dfn> within its range. It is
possible for the list of records which the cursor is iterating over to
change before the full <a>range</a> of the cursor has been iterated.
In order to handle this, cursors maintain their <a>position</a> not as
an index, but rather as a <a>key</a> of the previously returned
record. For a forward iterating cursor, the next time the cursor is
asked to iterate to the next record it returns the record with the
lowest <a>key</a> <a>greater than</a> the one previously returned. For
a backwards iterating cursor, the situation is opposite and it returns
the record with the highest <a>key</a> <a>less than</a> the one
previously returned.

For cursors iterating indexes the situation is a little bit more
complicated since multiple records can have the same key and are
therefore also sorted by <a>value</a>. When iterating indexes the
<a>cursor</a> also has an <dfn>object store position</dfn>, which
indicates the <a>value</a> of the previously found <a>record</a> in
the index. Both <a>position</a> and the <a>object store position</a>
are used when finding the next appropriate record.

A <a>cursor</a> has a <dfn data-lt-noDefault
data-lt="cursor.key">key</dfn> and a <dfn data-lt-noDefault
data-lt="cursor.value">value</dfn> which represent the <a>key</a> and
the <a>value</a> of the last iterated <a>record</a>.

A <a>cursor</a> has a <dfn>got value flag</dfn>. When this flag unset,
the cursor is either in the process of loading the next value or it
has reached the end of its <a>range</a>. When it is set, it indicates
that the cursor is currently holding a value and that it is ready to
iterate to the next one.

If the <a data-lt="cursor.source">source</a> of a cursor is an
<a>object store</a>, the <dfn>effective object store</dfn> of the
cursor is that object store and the <dfn>effective key</dfn> of the
cursor is the cursor's <a>position</a>. If the <a
data-lt="cursor.source">source</a> of a cursor is an <a>index</a>, the
<a>effective object store</a> of the cursor is that index's
<a>referenced</a> object store and the <a>effective key</a> is the
cursor's <a>object store position</a>.

A <a>cursor</a> also has a <dfn>key only flag</dfn>, that indicates
whether the cursor's <a data-lt="cursor.value">value</a> is exposed
via the API. Unless stated otherwise it is unset.


<!-- ============================================================ -->
<h4 id=key-generator-concept>Key Generators</h4>
<!-- ============================================================ -->

When a <a>object store</a> is created it can be specified to use a
<dfn data-lt="key generators">key generator</dfn>. A <a>key
generator</a> keeps an internal <dfn>current number</dfn>. The
<a>current number</a> is always a positive integer. Whenever the key
generator is used to generate a new <a>key</a>, the generator's
<a>current number</a> is returned and <strong>then</strong>
incremented to prepare for the next time a new <a>key</a> is needed.
Implementations MUST use the following rules for generating numbers
when a <a>key generator</a> is used.

* Every object store that uses key generators use a separate
    generator. I.e. interacting with one object store never affects
    the key generator of any other object store.

* The <a>current number</a> of a <a>key generator</a> is always set to
    1 when the <a>object store</a> for that key generator is first
    created.

* When a key generator is used to generate a new <a>key</a> for a
    <a>object store</a>, the key generator's <a>current number</a> is
    used as the new key value and then the key generator's <a>current
    number</a> is increased by 1.

* When a <a>record</a> is stored and a <a>key</a> is specified in the
    call to store the record, if <a data-lt="key.type">type</a> of the
    key is <i>number</i> and the <a data-lt="key.value">value</a> is
    greater than or equal to the key generator's <a>current
    number</a>, then the key generator's <a>current number</a> is set
    to the smallest integer number <a>greater than</a> the explicit
    key. A key can be specified both for object stores which use
    <a>in-line keys</a>, by setting the property on the stored value
    which the <a data-lt="objectStore.keyPath">object store's key
    path</a> points to, and for object stores which use <a>out-of-line
    keys</a>, by passing a key argument to the call to store the
    <a>record</a>.

    <aside class=note>
      Only specified keys of <a data-lt="key.type">type</a>
      <i>number</i> may affect the <a>current number</a> of the key
      generator. Keys of <a data-lt="key.type">type</a> <i>date</i>,
      <i>array</i> (regardless of the other keys they contain),
      <i>binary</i>, or <i>string</i> (regardless of whether they
      could be parsed as numbers) have no effect on the <a>current
      number</a> of the key generator. Keys of <a
      data-lt="key.type">type</a> <i>number</i> with <a
      data-lt="key.value">value</a> less than 1 do not affect the
      <a>current number</a> since they are always lower than the
      <a>current number</a>.
    </aside>

* Modifying a key generator's <a>current number</a> is considered part
    of a database operation. This means that if the operation fails
    and the operation is reverted, the <a>current number</a> is
    reverted to the value it had before the operation started. This
    applies both to modifications that happen due to the <a>current
    number</a> getting increased by 1 when the key generator is used,
    and to modifications that happen due to a <a>record</a> being
    stored with a key value specified in the call to store the
    <a>record</a>.

* Likewise, if a <a>transaction</a> is aborted, the <a>current
    number</a> of the key generator for each <a>object store</a> in
    the transaction's <a>scope</a> is reverted to the value it had
    before the <a>transaction</a> was started.

* When the <a>current number</a> of a key generator reaches above the
    value 2<sup>53</sup> (9007199254740992) any attempts to use the
    key generator to generate a new <a>key</a> will result in a
    <a>ConstraintError</a>. It is still possible to insert
    <a>records</a> into the object store by specifying an explicit
    key, however the only way to use a key generator again for the
    object store is to delete the object store and create a new one.

    <aside class=note>
      As long as key generators are used in a normal fashion this will
      not be a problem. If you generate a new key 1000 times per
      second day and night, you won't run into this limit for over
      285000 years.
    </aside>

* The <a>current number</a> for a key generator never decreases, other
    than as a result of database operations being reverted. Deleting a
    <a>record</a> from an <a>object store</a> never affects the object
    store's key generator. Even clearing all records from an object
    store, for example using the {{clear()}} method,
    does not affect the <a>current number</a> of the object store's
    key generator.

A practical result of this is that the first key generated for an
object store is always 1 (unless a higher numeric key is inserted
first) and the key generated for an object store is always a positive
integer higher than the highest numeric key in the store. The same key
is never generated twice for the same object store unless a
transaction is rolled back.

<aside class=example>

Each object store gets its own key generator:

<pre class=lang-javascript>
store1 = db.createObjectStore("store1", { autoIncrement: true });
store1.put("a"); // Will get key 1
store2 = db.createObjectStore("store2", { autoIncrement: true });
store2.put("a"); // Will get key 1
store1.put("b"); // Will get key 2
store2.put("b"); // Will get key 2
</pre>

If an insertion fails due to constraint violations or IO error, the
key generator is not updated.

<pre class=lang-javascript>
transaction.onerror = function(e) { e.preventDefault() };
store = db.createObjectStore("store1", { autoIncrement: true });
index = store.createIndex("index1", "ix", { unique: true });
store.put({ ix: "a"}); // Will get key 1
store.put({ ix: "a"}); // Will fail
store.put({ ix: "b"}); // Will get key 2
</pre>

Removing items from an objectStore never affects the key generator.
Including when <code>clear()</code> is called.

<pre class=lang-javascript>
store = db.createObjectStore("store1", { autoIncrement: true });
store.put("a"); // Will get key 1
store.delete(1);
store.put("b"); // Will get key 2
store.clear();
store.put("c"); // Will get key 3
store.delete(IDBKeyRange.lowerBound(0));
store.put("d"); // Will get key 4
</pre>

Inserting an item with an explicit key affects the key generator if,
and only if, the key is numeric and higher than the last generated
key.

<pre class=lang-javascript>
store = db.createObjectStore("store1", { autoIncrement: true });
store.put("a"); // Will get key 1
store.put("b", 3); // Will use key 3
store.put("c"); // Will get key 4
store.put("d", -10); // Will use key -10
store.put("e"); // Will get key 5
store.put("f", 6.00001); // Will use key 6.0001
store.put("g"); // Will get key 7
store.put("f", 8.9999); // Will use key 8.9999
store.put("g"); // Will get key 9
store.put("h", "foo"); // Will use key "foo"
store.put("i"); // Will get key 10
store.put("j", [1000]); // Will use key [1000]
store.put("k"); // Will get key 11
// All of these would behave the same if the objectStore used a
// keyPath and the explicit key was passed inline in the object
</pre>

Aborting a transaction rolls back any increases to the key generator
which happened during the transaction. This is to make all rollbacks
consistent since rollbacks that happen due to crash never has a chance
to commit the increased key generator value.

<pre class=lang-javascript>
db.createObjectStore("store", { autoIncrement: true });
trans1 = db.transaction(["store"], "readwrite");
store_t1 = trans1.objectStore("store");
store_t1.put("a"); // Will get key 1
store_t1.put("b"); // Will get key 2
trans1.abort();
trans2 = db.transaction(["store"], "readwrite");
store_t2 = trans2.objectStore("store");
store_t2.put("c"); // Will get key 1
store_t2.put("d"); // Will get key 2
</pre>
</aside>

<aside class=example>

The following examples illustrate the different behaviors when trying
to use in-line <a>keys</a> and <a>key generators</a> to save an object
to an <a>object store</a>.

If the following conditions are true:

* The <a>object store</a> has a <a>key generator</a>.
* There is no in-line value for the <a>key path</a> property.

Then the value provided by the <a>key generator</a> is used to
populate the key value. In the example below the <a>key path</a> for
the object store is "<code>foo.bar</code>". The actual object has no
value for the <code>bar</code> property, <code>{ foo: {} }</code>.
When the object is saved in the <a>object store</a> the
<code>bar</code> property is assigned a value of 1 because that is the
next <a>key</a> generated by the <a>key generator</a>.

<pre class=lang-javascript>
var store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: {} }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 1);
};
</pre>

If the following conditions are true:

* The <a>object store</a> has a <a>key generator</a>.
* There is a value for the <a>key path</a> property.

Then the value associated with the <a>key path</a> property is used.
The auto-generated <a>key</a> is not used. In the example below the
<a>key path</a> for the <a>object store</a> is "<code>foo.bar</code>".
The actual object has a value of 10 for the <code>bar</code> property,
<code>{ foo: { bar: 10} }</code>. When the object is saved in the
<a>object store</a> the <code>bar</code> property keeps its value of
10, because that is the key value.

<pre class=lang-javascript>
var store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: { bar: 10 } }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 10);
};
</pre>

The following example illustrates the scenario when the specified
in-line <a>key</a> is defined through a <a>key path</a> but there is
no property matching it. The value provided by the <a>key
generator</a> is then used to populate the key value and the system is
responsible for creating as many properties as it requires to suffice
the property dependencies on the hierarchy chain. In the example below
the <a>key path</a> for the <a>object store</a> is
"<code>foo.bar.baz</code>". The actual object has no value for the
<code>foo</code> property, <code>{ zip: {} }</code>. When the object
is saved in the <a>object store</a> the <code>foo</code>,
<code>bar</code>, and <code>baz</code> properties are created each as
a child of the other until a value for <code>foo.bar.baz</code> can be
assigned. The value for <code>foo.bar.baz</code> is the next key
generated by the object store.

<pre class=lang-javascript>
var store = db.createObjectStore("store", { keyPath: "foo.bar.baz", autoIncrement: true });
store.put({ zip: {} }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 1);
  store.get(key).onsuccess = function(e) {
    var value = e.target.result;
    // value will be: { zip: {}, foo: { bar: { baz: 1 } } }
    console.assert(value.foo.bar.baz === 1);
  };
};
</pre>

Attempting to store a property on a primitive value will fail and
throw an error. In the first example below the <a>key path</a> for the
object store is "<code>foo</code>". The actual object is a primitive
with the value, <code>4</code>. Trying to define a property on that
primitive value fails. The same is true for arrays. Properties are not
allowed on an array. In the second example below, the actual object is
an array, <code>[10]</code>. Trying to define a property on the array
fails.

<pre class=lang-javascript>
var store = db.createObjectStore("store", { keyPath: "foo", autoIncrement: true });

// The key generation will attempt to create and store the key path property on this primitive.
store.put(4); // will throw DataError

// The key generation will attempt to create and store the key path property on this array.
store.put([10]); // will throw DataError
</pre>
</aside>


<!-- ============================================================ -->
<h3 id=exceptions>Exceptions</h3>
<!-- ============================================================ -->

Each of the exceptions defined in this document is a
<a>DOMException</a> with a specific type. The exception types and
properties such as code value are defined in [[!WEBIDL]].

<table>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td><code><dfn>AbortError</dfn></code></td>
<td>A request was aborted.</td>
</tr>
<tr>
<td><code><dfn>ConstraintError</dfn></code></td>
<td>A mutation operation in the transaction failed because a constraint was not satisfied.</td>
</tr>
<tr>
<td><code><dfn>DataCloneError</dfn></code></td>
<td>The data being stored could not be cloned by the internal structured cloning algorithm.</td>
</tr>
<tr>
<td><code><dfn>DataError</dfn></code></td>
<td>Data provided to an operation does not meet requirements.</td>
</tr>
<tr>
<td><code><dfn>InvalidAccessError</dfn></code></td>
<td>An invalid operation was performed on an object.</td>
</tr>
<tr>
<td><code><dfn>InvalidStateError</dfn></code></td>
<td>
An operation was called on an object on which it is not allowed or at a time when it is not allowed,
or if a request is made on a source object that has been deleted or removed.
</td>
</tr>
<tr>
<td><code><dfn>NotFoundError</dfn></code></td>
<td>
The operation failed because the requested database object could not be found.
</td>
</tr>
<tr>
<td><code><dfn>QuotaExceededError</dfn></code></td>
<td>
The operation failed because there was not enough remaining storage space,
or the storage quota was reached and the user declined to give more space to the database.
</td>
</tr>
<tr>
<td><code><dfn>SyntaxError</dfn></code></td>
<td>The keyPath argument contains an invalid key path.</td>
</tr>
<tr>
<td><code><dfn>ReadOnlyError</dfn></code></td>
<td>The mutating operation was attempted in a read-only transaction.</td>
</tr>
<tr>
<td><code><dfn>TransactionInactiveError</dfn></code></td>
<td>A request was placed against a transaction which is currently not active, or which is finished.</td>
</tr>
<tr>
<td><code><dfn>UnknownError</dfn></code></td>
<td>The operation failed for reasons unrelated to the database itself and not covered by any other errors.</td>
</tr>
<tr>
<td><code><dfn>VersionError</dfn></code></td>
<td>An attempt was made to open a database using a lower version than the existing version.</td>
</tr>
</table>

<aside class=note>
Given that multiple Indexed DB operations can throw the same type of
error, and that a even single operation can throw the same type of
error for multiple reasons, implementations are encouraged to provide
more specific messages to enable developers to identify the cause of
errors.
</aside>

<!-- ============================================================ -->
<h3 id=async-api>API</h3>
<!-- ============================================================ -->

The API methods return without blocking the calling thread. All
asynchronous operations immediately return an {{IDBRequest}}
instance. This object does not initially contain any information about
the result of the operation. Once information becomes available, an
event is fired on the request and the information becomes available
through the properties of the {{IDBRequest}} instance.

The <span>task source</span> for these tasks is the <dfn
id="database-access-task-source">database access task source</dfn>.


<!-- ============================================================ -->
<h4 id=request-api>The <code>IDBRequest</code> interface</h4>
<!-- ============================================================ -->

The {{IDBRequest}} interface provides the means to access results of
asynchronous requests to <a>databases</a> and <a>database</a>
objects using <a>event handler IDL attributes</a> [[!HTML]].

Every method for making asynchronous requests returns an
{{IDBRequest}} object that communicates back to the requesting
application through events. This design means that any number of
requests can be active on any <a>database</a> at a time.

<aside class=example>

In the following example, we open a <a>database</a> asynchronously.
Various event handlers are registered for responding to various
situations.

<pre class=lang-javascript>
var request = indexedDB.open('AddressBook', 15);
request.onsuccess = function(evt) {...};
request.onerror = function(evt) {...};
</pre>
</aside>

<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBRequest : EventTarget {
  readonly    attribute any                                        result;
  readonly    attribute DOMException                               error;
  readonly    attribute (IDBObjectStore or IDBIndex or IDBCursor)? source;
  readonly    attribute IDBTransaction                             transaction;
  readonly    attribute IDBRequestReadyState                       readyState;

  // Event handlers:
  attribute EventHandler                               onsuccess;
  attribute EventHandler                               onerror;
};

enum IDBRequestReadyState {
  "pending",
  "done"
};
</pre>

The {{IDBRequest/result}}
attribute's getter must <a>throw</a> an <a>InvalidStateError</a>
exception if the <a>done flag</a> is unset. Otherwise, the attribute's
getter must return the <a data-lt="request.result">result</a> of the
request, or undefined if the request.resulted in an error.

The {{IDBRequest/error}}
attribute's getter must <a>throw</a> an <a>InvalidStateError</a>
exception if the <a>done flag</a> is unset. Otherwise, the attribute's
getter must return the <a data-lt="request.error">error</a> of the
request, or null if no error occurred.

The {{IDBRequest/source}}
attribute's getter must return the <a
data-lt="request.source">source</a> of the <a>request</a>, or null if
no <a data-lt="request.source">source</a> is set.

The {{IDBRequest/transaction}} attribute's getter
must return the <a data-lt="request.transaction">transaction</a> of
the <a>request</a>. This property can be null for certain requests,
such as for <a>request</a> returned from {{IDBFactory/open()}}.

The {{IDBRequest/readyState}} attribute's getter must return
"<code>pending</code>" if the <a>done flag</a> is unset, and
"<code>done</code>" otherwise.

The {{IDBRequest/onsuccess}} attribute is the event handler for the
<code>success</code> event.

The {{IDBRequest/onerror}} attribute is the event handler for the
<code>error</code> event.


Methods on {{IDBDatabase}} that return a <a>open request</a> use
an extended interface to allow listening to the
<a>blocked</a> event and <a>upgradeneeded</a> event.

<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBOpenDBRequest : IDBRequest {
  // Event handlers:
  attribute EventHandler onblocked;
  attribute EventHandler onupgradeneeded;
};
</pre>

The {{IDBOpenDBRequest/onblocked}} attribute is the event handler for the
<a>blocked</a> event.

The {{IDBOpenDBRequest/onupgradeneeded}} attribute is the event handler for the
<a>upgradeneeded</a> event.


<!-- ============================================================ -->
<h4 id=events>Event interfaces</h4>
<!-- ============================================================ -->

This specification fires events with the following custom interfaces:

<pre class="idl">
[Exposed=(Window,Worker), Constructor(DOMString type, optional IDBVersionChangeEventInit eventInitDict)]
interface IDBVersionChangeEvent : Event {
  readonly    attribute unsigned long long  oldVersion;
  readonly    attribute unsigned long long? newVersion;
};

dictionary IDBVersionChangeEventInit : EventInit {
  unsigned long long  oldVersion = 0;
  unsigned long long? newVersion = null;
};
</pre>

The {{IDBVersionChangeEvent/oldVersion}} attribute
getter returns the previous version of the database.

The {{IDBVersionChangeEvent/newVersion}} attribute
getter returns the new version of the database, or null if the
database is being deleted. See the <a>steps for running an upgrade
transaction</a>.


Events are constructed as defined in <a
href="https://dom.spec.whatwg.org/#constructing-events">Constructing
events</a>, in [[!WHATWG-DOM]].

To <dfn>fire a version change event</dfn> named <var>e</var> at
<var>target</var> given <var>oldVersion</var> and
<var>newVersion</var>, dispatch an event at <var>target</var>.

The event MUST use the {{IDBVersionChangeEvent}} interface with its
<code>type</code> set to <var>e</var>, its
{{IDBVersionChangeEvent/oldVersion}} attribute set to
<var>oldVersion</var>, and its {{IDBVersionChangeEvent/newVersion}}
attribute set to <var>newVersion</var>. This event MUST NOT bubble or
be cancelable.


<!-- ============================================================ -->
<h4 id=factory-interface>The <code>IDBFactory</code> interface</h4>
<!-- ============================================================ -->

<a>Database</a> objects are accessed through methods on the
{{IDBFactory}} interface. A single object implementing this
interface is present in the global scope of environments that support
Indexed DB operations.


<pre class="idl">
[NoInterfaceObject]
interface IDBEnvironment {
  readonly    attribute IDBFactory indexedDB;
};
Window implements IDBEnvironment;
WorkerGlobalScope implements IDBEnvironment;
</pre>

The {{IDBEnvironment/indexedDB}} attribute provides applications a
mechanism for accessing capabilities of indexed databases.

<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBFactory {
  IDBOpenDBRequest open(DOMString name, [EnforceRange] optional unsigned long long version);
  IDBOpenDBRequest deleteDatabase(DOMString name);

  short            cmp(any first, any second);
};
</pre>

The <dfn method for=IDBFactory>open(<var>name</var>, <var>version</var>)</dfn> method, when invoked, must run these steps:

1. If <var>version</var> is 0 (zero), <a>throw</a> a <a>TypeError</a>.

2. Let <var>request</var> be a new <a>open request</a>.

3. <a>Queue a task</a> to run these substeps:

    1. Let <var>result</var> be the result of running the <a>steps for opening a database</a>, with
        the origin of the {{IDBEnvironment}} used to access this {{IDBFactory}},
        <var>name</var>,
        <var>version</var> if given and undefined otherwise, and
        <var>request</var>.

        <aside class=note>
          If <var>version</var> is not given and a <a>database</a>
          with that name already exists, a connection will be opened
          without changing the <a>version</a>. If <var>version</var>
          is not given and no <a>database</a> with that name exists, a
          new <a>database</a> will be created with <a>version</a>
          equal to 1.
        </aside>

    2. If <var>result</var> is an error, set the <a
        data-lt="request.error">error</a> of <var>request</var> to
        <var>result</var> and dispatch an event at <var>request</var>.
        The event must use the <a>Event</a> interface and set the
        <code>type</code> attribute to "<code>error</code>". The event
        does bubble but is not cancelable.

    3. Otherwise, set the <a data-lt="request.result">result</a> of
        <var>request</var> to <var>result</var> and dispatch an event
        at <var>request</var>. The event must use the <a>Event</a>
        interface and set the <code>type</code> attribute to
        "<code>success</code>". The event does not bubble and is not
        cancelable. If the steps above resulted in an <a>upgrade
        transaction</a> being run, then firing the
        "<code>success</code>" event MUST be done after the <a>upgrade
        transaction</a> completes.

        <aside class=note>
          The last requirement is to ensure that in case another
          version upgrade is about to happen, the success event is
          fired on the connection first so that the script gets a
          chance to register a listener for the
          <code>versionchange</code> event.
        </aside>

        <aside class=note>
          The firing of "<code>success</code>" or "<code>error</code>"
          events do not follow the normal steps to <a>fire a success
          event</a> or <a>fire an error event</a> as there is no
          active transaction at the time when they fire.
        </aside>

4. Return a new {{IDBOpenDBRequest}} object for <var>request</var>.


The <dfn method for=IDBFactory>deleteDatabase(<var>name</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>request</var> be a new <a>open request</a>.

2. <a>Queue a task</a> to run these substeps:

    1. Let <var>result</var> be the result of running the <a>steps for
        deleting a database</a>, with the origin of the
        {{IDBEnvironment}} used to access this {{IDBFactory}},
        <var>name</var>, and <var>request</var>.

    2. If <var>result</var> is an error set the <a
        data-lt="request.error">error</a> of <var>request</var> to
        <var>result</var> and dispatch an event at <var>request</var>.
        The event must use the <a>Event</a> interface and set the
        <code>type</code> attribute to "<code>error</code>". The event
        does bubble but is not cancelable.

    3. Otherwise, set the <a data-lt="request.result">result</a> of
        <var>request</var> to undefined and <a>fire a version change
        event</a> named <code>success</code> at <a>request</a> with
        <var>result</var> and null.

        <aside class=note>
          The firing of "<code>success</code>" or "<code>error</code>"
          events do not follow the normal steps to <a>fire a success
          event</a> or <a>fire an error event</a> as there is no
          active transaction at the time when they fire.
        </aside>

3. Return a new {{IDBOpenDBRequest}} object for <var>request</var>.


The <dfn method for=IDBFactory>cmp(<var>first</var>, <var>second</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>a</var> be the result of running the steps to <a>convert a
    value to a key</a> with <var>first</var>. If this throws an
    exception, <a>rethrow</a> it.

2. If <var>a</var> is invalid, <a>throw</a> a <a>DataError</a> exception.

3. Let <var>b</var> be the result of running the steps to <a>convert a
    value to a key</a> with <var>second</var>. If this throws an
    exception, <a>rethrow</a> it.

4. If <var>b</var> is invalid, <a>throw</a> a <a>DataError</a> exception.

5. Return the results of running the steps to <a>compare two keys</a>
    with <var>a</var> and <var>b</var>.


<!-- ============================================================ -->
<h4 id=database-interface>The <code>IDBDatabase</code> interface</h4>
<!-- ============================================================ -->

The {{IDBDatabase}}
interface represents a <a>connection</a> to a <a>database</a>.

An {{IDBDatabase}} object MUST NOT be garbage collected if its
associated <a>connection</a>'s <a>close pending flag</a> is unset
and it has one or more event listeners registers whose type is one of
<code>abort</code>, <code>error</code>, or <code>versionchange</code>.

If an {{IDBDatabase}} object is garbage collected, the
associated <a>connection</a> must be <a data-lt="database close">closed</a>.


<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBDatabase : EventTarget {
  readonly    attribute DOMString          name;
  readonly    attribute unsigned long long version;
  readonly    attribute DOMStringList      objectStoreNames;

  IDBTransaction transaction((DOMString or sequence&lt;DOMString&gt;) storeNames, optional IDBTransactionMode mode = "readonly");
  void           close();

  IDBObjectStore createObjectStore(DOMString name, optional IDBObjectStoreParameters options);
  void           deleteObjectStore(DOMString name);

  // Event handlers:
  attribute EventHandler       onabort;
  attribute EventHandler       onclose;
  attribute EventHandler       onerror;
  attribute EventHandler       onversionchange;
};

dictionary IDBObjectStoreParameters {
  (DOMString or sequence&lt;DOMString&gt;)? keyPath = null;
  boolean                             autoIncrement = false;
};
</pre>

The {{IDBDatabase/name}}
attribute's getter must return the <a data-lt="database.name">name</a>
of the <a data-lt="connection">connected</a> <a>database</a>. The
attribute MUST return this name even if the <a>close pending flag</a>
is set on the <a>connection</a>. In other words, the value of this
attribute stays constant for the lifetime of the {{IDBDatabase}}
instance.

The {{IDBDatabase/version}}
attribute's getter must return this <a>connection</a>'s <a
data-lt="connection.version">version</a>.

<aside class=note>
  As long as the <a>connection</a> is open, this is the same as the
  connected <a>database</a>'s <a>version</a>.

  Once the <a>connection</a> has <a data-lt="database
  close">closed</a>, this attribute will not reflect changes made with
  a later <a>upgrade transaction</a>.
</aside>


The {{IDBDatabase/objectStoreNames}}
attribute's getter must return a <a>sorted list</a> of the <a
data-lt="objectStore.name">names</a> of the <a>object stores</a> in
this <a>connection</a>'s <a>object store set</a>.

<aside class=note>
  As long as the <a>connection</a> is open, this is the same as the
  connected <a>database</a>'s <a>object store</a> <a
  data-lt="objectStore.name">names</a>.

  Once the <a>connection</a> has <a data-lt="database
  close">closed</a>, this attribute will not reflect changes made with
  a later <a>upgrade transaction</a>.
</aside>

The <dfn method for=IDBDatabase>createObjectStore(<var>name</var>, <var>options</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>database</var> be the <a>database</a> associated with this <a>connection</a>.

2. Let <var>transaction</var> be the currently running <a>upgrade transaction</a> associated with
    <var>database</var>, or <a>throw</a> an <a>InvalidStateError</a> exception if none.

3. If <var>transaction</var> is not <a>active</a>,
    <a>throw</a> a <a>TransactionInactiveError</a> exception.

4. If an <a>object store</a> <a data-lt="objectStore.name">named</a> <var>name</var> already exists in
    <var>database</var>
    <a>throw</a> a <a>ConstraintError</a> exception.

5. Let <var>keyPath</var> be <var>options</var>'s <code>keyPath</code> member if it is not undefined or null, or null otherwise.

6. If <var>keyPath</var> is not null and is not a <a>valid key path</a>,
    <a>throw</a> a <a>SyntaxError</a> exception.

7. Let <var>autoIncrement</var> be set if <var>options</var>'s <code>autoIncrement</code> member is true, or unset otherwise.
8. If <var>autoIncrement</var> is set and <var>keyPath</var> is an empty string or any sequence (empty or otherwise),
    <a>throw</a> an <a>InvalidAccessError</a> exception.

9. Let <var>store</var> be a new <a>object store</a> in <var>database</var>.
    Set the created <a>object store</a>'s <a data-lt="objectStore.name">name</a> to <var>name</var>.
    If <var>autoIncrement</var> is set, then the created <a>object store</a> uses a <a>key generator</a>.
    If <var>keyPath</var> is not null, set the created <a>object store</a>'s <a data-lt="objectStore.keyPath">key path</a> to <var>keyPath</var>.

10. Return a new <a>object store handle</a> associated with <var>store</var> and <var>transaction</var>.


This method creates and returns a new <a>object store</a> with the
given name in the <a lt="connection">connected</a> <a>database</a>.
Note that this method must only be called from within an <a>upgrade
transaction</a>.

This method synchronously modifies the
{{IDBDatabase/objectStoreNames}} property on the {{IDBDatabase}}
instance on which it was called.

In some implementations it is possible for the implementation to run
into problems after queuing a task to create the <a>object store</a>
after the <code>createObjectStore()</code> method has returned. For
example in implementations where metadata about the newly created
<a>object store</a> is inserted into the database asynchronously, or
where the implementation might need to ask the user for permission for
quota reasons. Such implementations MUST still create and return an
{{IDBObjectStore}} object, and once the implementation determines
that creating the <a>object store</a> has failed, it MUST abort the
transaction using the <a>steps for aborting a transaction</a> using
the appropriate error. For example if creating the <a>object store</a>
failed due to quota reasons, <a>QuotaExceededError</a> MUST be used as
error.

The <dfn method for=IDBDatabase>deleteObjectStore(<var>name</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>database</var> be the <a>database</a> associated with this <a>connection</a>.

2. Let <var>transaction</var> be the currently running <a>upgrade transaction</a> associated with
    <var>database</var>, or <a>throw</a> an <a>InvalidStateError</a> exception if none.

3. If <var>transaction</var> is not <a>active</a>,
    <a>throw</a> a <a>TransactionInactiveError</a> exception.

4. Let <var>store</var> be the <a>object store</a> <a data-lt="objectStore.name">named</a> <var>name</var> in <var>database</var>,
    or <a>throw</a> a <a>NotFoundError</a> exception if none.

5. Remove <var>store</var> from this <a>connection</a>'s <a>object store set</a>.

6. Destroy <var>store</var>.

This method destroys the <a>object store</a> with the given name in
the <a lt="connection">connected</a> <a>database</a>. Note that this
method must only be called from within an <a>upgrade transaction</a>.

This method synchronously modifies the
{{IDBDatabase/objectStoreNames}} property on the {{IDBDatabase}}
instance on which it was called.


The <dfn method for=IDBDatabase>transaction(<var>storeNames</var>, <var>mode</var>)</dfn> method, when invoked, must run these steps:

1. If <var>mode</var> parameter is not "<code>readonly</code>" or "<code>readwrite</code>",
    <a>throw</a> a <a>TypeError</a>.

2. If this method is called on {{IDBDatabase}} object for which an <a>upgrade transaction</a> is still running,
    <a>throw</a> an <a>InvalidStateError</a> exception.

3. If this method is called on an {{IDBDatabase}} instance where the <a>close pending flag</a> is set,
    <a>throw</a> an <a>InvalidStateError</a> exception.

4. Let <var>scope</var> be the set of unique strings in <var>storeNames</var> if it is a sequence,
    or a set containing one string equal to <var>storeNames</var> otherwise.

5. If any string in <var>scope</var> is not the name of an <a>object store</a> in the <a data-lt="connection">connected</a> <a>database</a>,
    <a>throw</a> a <a>NotFoundError</a> exception.

6. If <var>scope</var> is empty,
    <a>throw</a> an <a>InvalidAccessError</a> exception.

7. Let <var>transaction</var> be a <a data-lt="transaction create">new transaction</a>
    with <var>connection</var>, <var>mode</var> and the set of <a>object stores</a> named in <var>scope</var>.

8. When control is returned to the event loop, the implementation MUST unset the <a>active flag</a>.

    <aside class="issue">Specify this more precisely in terms of tasks and microtasks.</aside>

9. Return an {{IDBTransaction}} object representing <var>transaction</var>.

<aside class=note>
  The created <var>transaction</var> will follow the <a>transaction lifetime</a> rules.
</aside>


The <dfn method for=IDBDatabase>close()</dfn> method, when invoked, must run these steps:

1. Run the <a>steps for closing a database connection</a> with this <a>connection</a>.


The {{IDBDatabase/onabort}} attribute is the event handler for the
<code>abort</code> event.

The {{IDBDatabase/onclose}} attribute is the event handler for the
<code>close</code> event.

<aside class=note>&#9752; The {{IDBDatabase/onclose}} attribute is new in this edition. &#9752;</aside>

The {{IDBDatabase/onerror}} attribute is the event handler for the
<code>error</code> event.

The {{IDBDatabase/onversionchange}} attribute is the event handler for the
<code>versionchange</code> event.


<!-- ============================================================ -->
<h4 id=object-store-interface>The <code>IDBObjectStore</code> interface</h4>
<!-- ============================================================ -->

The {{IDBObjectStore}}
interface represents an <a>object store handle</a>.

<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBObjectStore {
  attribute DOMString      name;
  readonly    attribute any            keyPath;
  readonly    attribute DOMStringList  indexNames;
  readonly    attribute IDBTransaction transaction;
  readonly    attribute boolean        autoIncrement;

  IDBRequest put(any value, optional any key);
  IDBRequest add(any value, optional any key);
  IDBRequest delete(any query);
  IDBRequest clear();
  IDBRequest get(any query);
  IDBRequest getKey(any query);
  IDBRequest getAll(optional any query, [EnforceRange] optional unsigned long count);
  IDBRequest getAllKeys(optional any query, [EnforceRange] optional unsigned long count);
  IDBRequest count(optional any query);

  IDBRequest openCursor(optional any query, optional IDBCursorDirection direction = "next");
  IDBRequest openKeyCursor(optional any query, optional IDBCursorDirection direction = "next");

  IDBIndex   index(DOMString name);

  IDBIndex   createIndex(DOMString name, (DOMString or sequence&lt;DOMString&gt;) keyPath, optional IDBIndexParameters options);
  void       deleteIndex(DOMString indexName);
};

dictionary IDBIndexParameters {
  boolean unique = false;
  boolean multiEntry = false;
};
</pre>

The {{IDBObjectStore/name}} attribute's getter must return this <a>object store
handle</a>'s <a data-lt="objectStore.name">name</a>.

<aside class=note>
  As long as the <a>transaction</a> has not <a data-lt="transaction
  finish">finished</a>, this is the same as the associated <a>object
  store</a>'s <a data-lt="objectStore.name">name</a>.

  Once the <a>transaction</a> has <a data-lt="transaction
  finish">finished</a>, this attribute will not reflect changes made
  with a later <a>upgrade transaction</a>.
</aside>


The {{IDBObjectStore/name}} attribute's setter must run these steps:

1. Let <var>name</var> be the given value.

2. Let <var>transaction</var> be this <a>object store handle</a>'s <a data-lt="objectStoreHandle.transaction">transaction</a>.

3. Let <var>store</var> be this <a>object store handle</a>'s <a data-lt="objectStoreHandle.objectStore">object store</a>.

4. If <var>store</var> has been deleted,
    <a>throw</a> an <a>InvalidStateError</a> exception.

5. If <var>transaction</var> is not an <a>upgrade transaction</a>,
    <a>throw</a> an <a>InvalidStateError</a> exception.

6. If <var>transaction</var> is not <a>active</a>,
    <a>throw</a> a <a>TransactionInactiveError</a> exception.

7. If <var>store</var>'s <a data-lt="objectStore.name">name</a> is equal to <var>name</var>, terminate these steps.

8. If an <a>object store</a> <a data-lt="objectStore.name">named</a> <var>name</var> already exists in
    <var>store</var>'s <a>database</a>,
    <a>throw</a> a <a>ConstraintError</a> exception.

9. Set <var>store</var>'s <a data-lt="objectStore.name">name</a> to <var>name</var>.

10. Set this <a>object store handle</a>'s <a data-lt="objectStoreHandle.name">name</a> to <var>name</var>.

<aside class=note>&#9752; The {{IDBObjectStore/name}} attribute's setter is new in this edition. &#9752;</aside>


The {{IDBObjectStore/keyPath}} attribute's getter must
return this <a>object store handle</a>'s <a
data-lt="objectStoreHandle.objectStore">object store</a>'s <a
data-lt="objectStore.keyPath">key path</a>, or null if none.

The conversion is done following the normal [[!WEBIDL]] binding logic for
<a>DOMString</a> and <a>sequence&lt;DOMString&gt;</a> values,
as appropriate.

The returned value is not the same instance that was used when the
<a>object store</a> was created. However, if this attribute returns an
object (specifically an <a>Array</a>), it returns the same object
instance every time it is inspected. Changing the properties of the
object has no effect on the <a>object store</a>.


The {{IDBObjectStore/indexNames}} attribute's
getter must return a <a>sorted list</a> of the <a
data-lt="index.name">names</a> of <a>indexes</a> in this <a>object
store handle</a>'s <a>index set</a>.

<aside class=note>
  As long as the <a>transaction</a> has not <a data-lt="transaction
  finish">finished</a>, this is the same as the associated <a>object
  store</a>'s list of <a>index</a> <a data-lt="index.name">names</a>.

  Once the <a>transaction</a> has <a data-lt="transaction
  finish">finished</a>, this attribute will not reflect changes made
  with a later <a>upgrade transaction</a>.
</aside>

The {{IDBObjectStore/transaction}} attribute's
getter must return this <a>object store handle</a>'s <a
data-lt="objectStoreHandle.transaction">transaction</a>,

The {{IDBObjectStore/autoIncrement}} attribute's
getter must return true if this <a>object store handle</a>'s <a
data-lt="objectStoreHandle.objectStore">object store</a> has a <a>key
generator</a>, and false otherwise.


The <dfn method for=IDBObjectStore>put(<var>value</var>, <var>key</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted,
    <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>,
    <a>throw</a> a <a>TransactionInactiveError</a> exception.

5. If <var>transaction</var> is a <a>read-only transaction</a>,
    <a>throw</a> a <a>ReadOnlyError</a> exception.

6. If <var>store</var> uses <a>in-line keys</a> and <var>key</var> was given,
    <a>throw</a> a <a>DataError</a> exception.

7. If <var>store</var> uses <a>out-of-line keys</a> and has no <a>key generator</a>
    and <var>key</var> was not given,
    <a>throw</a> a <a>DataError</a> exception.

8. If <var>key</var> was given, run these substeps:

    1. Let <var>r</var> be the result of running the steps to <a>convert a value to a key</a> with <var>key</var>.
        If this throws an exception, <a>rethrow</a> it.

    2. If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a> exception.

    3. Let <var>key</var> be <var>r</var>.

9. Let <var>clone</var> be <a>structured clone</a> of <var>value</var>. If this
    throws an exception, <a>rethrow</a> the exception.

10. If <var>store</var> uses <a>in-line keys</a>, run these substeps:

    1. Let <var>kpk</var> be the result of running the steps to
        <a>extract a key from a value using a key path</a> with
        <var>clone</var> and <var>store</var>'s <a
        data-lt="objectStore.keyPath">key path</a>. If this throws an
        exception, <a>rethrow</a> it.

    2. If <var>kpk</var> is invalid, <a>throw</a> a <a>DataError</a>
        exception.

    3. If <var>kpk</var> is not failure, let <var>key</var> be
        <var>kpk</var>.

    4. Otherwise, if <var>store</var> does not have a <a>key
        generator</a>, <a>throw</a> a <a>DataError</a> exception.

11. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for storing a record into an object store</a> as
    <var>operation</var>, using <var>store</var>, the <var>clone</var>
    as <var>value</var>, <var>key</var>, and with the
    <var>no-overwrite flag</var> unset.


The <dfn method for=IDBObjectStore>add(<var>value</var>, <var>key</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. If <var>transaction</var> is a <a>read-only transaction</a>,
    <a>throw</a> a <a>ReadOnlyError</a> exception.

6. If <var>store</var> uses <a>in-line keys</a> and <var>key</var> was given,
    <a>throw</a> a <a>DataError</a> exception.

7. If <var>store</var> uses <a>out-of-line keys</a> and has no <a>key generator</a>
    and <var>key</var> was not given,
    <a>throw</a> a <a>DataError</a> exception.

8. If <var>key</var> was given, run these substeps:

    1. Let <var>r</var> be the result of running the steps to
        <a>convert a value to a key</a> with <var>key</var>. If this
        throws an exception, <a>rethrow</a> it.

    2. If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a>
        exception.

    3. Let <var>key</var> be <var>r</var>.

9. Let <var>clone</var> be <a>structured clone</a> of
    <var>value</var>. If this throws an exception, <a>rethrow</a> the
    exception.

10. If <var>store</var> uses <a>in-line keys</a>, run these substeps:

    1. Let <var>kpk</var> be the result of running the steps to
        <a>extract a key from a value using a key path</a> with
        <var>clone</var> and <var>store</var>'s <a
        data-lt="objectStore.keyPath">key path</a>. If this throws an
        exception, <a>rethrow</a> it.

    2. If <var>kpk</var> is invalid, <a>throw</a> a <a>DataError</a>
        exception.

    3. If <var>kpk</var> is not failure, let <var>key</var> be
        <var>kpk</var>.

    4. Otherwise, if <var>store</var> does not have a <a>key
        generator</a>, <a>throw</a> a <a>DataError</a> exception.

11. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for storing a record into an object store</a> as
    <var>operation</var>, using <var>store</var>, <var>clone</var> as
    <var>value</var>, <var>key</var>, and with the <var>no-overwrite
    flag</var> set.

The <dfn method for=IDBObjectStore>delete(<var>query</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. If <var>transaction</var> is a <a>read-only transaction</a>,
    <a>throw</a> a <a>ReadOnlyError</a> exception.

6. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var> and
    <var>null disallowed flag</var> set. If this throws an exception,
    <a>rethrow</a> it.

7. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for deleting records from an object store</a> as
    <var>operation</var>, using <var>store</var> and <var>range</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>records</a> keys to be
deleted.

<aside class=note>
Unlike other methods which take keys or key ranges, this method does
<strong>not</strong> allow null to be given as key. This is to reduce
the risk that a small bug would clear a whole object store.
</aside>


The <dfn method for=IDBObjectStore>clear()</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. If <var>transaction</var> is a <a>read-only transaction</a>,
    <a>throw</a> a <a>ReadOnlyError</a> exception.

6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for clearing an object store</a> as
    <var>operation</var>, using <var>store</var>.


The <dfn method for=IDBObjectStore>get(<var>query</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var> and
    <var>null disallowed flag</var> set. If this throws an exception,
    <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
      return the {{IDBRequest}} created by these steps. The steps
      are run with this <a>object store handle</a> as
      <var>source</var> and the <a>steps for retrieving a value from
      an object store</a> as <var>operation</var>, using
      <var>store</var> and <var>range</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>record</a> to be retrieved. If a
range is specified, the method retrieves the first existing value in
that range.

<aside class=note>
  This method produces the same result if a record with the given key
  doesn't exist as when a record exists, but has undefined as value.
  If you need to tell the two situations apart, you can use
  {{IDBObjectStore/openCursor()}} with the same key. This will return
  a cursor with undefined as value if a record exists, or no cursor if
  no such record exists.
</aside>


The <dfn method for=IDBObjectStore>getKey(<var>query</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var> and
    <var>null disallowed flag</var> set. If this throws an exception,
    <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
      return the {{IDBRequest}} created by these steps. The steps
      are run with this <a>object store handle</a> as
      <var>source</var> and the <a>steps for retrieving a key from an
      object store</a> as <var>operation</var>, using <var>store</var>
      and <var>range</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>record</a> key to be
retrieved. If a range is specified, the method retrieves
the first existing key in that range.

<aside class=note>&#9752; The {{IDBObjectStore/getKey()}} method is new in this edition. &#9752;</aside>


The <dfn method for=IDBObjectStore>getAll(<var>query</var>, <var>count</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for retrieving multiple values from an object
    store</a> as <var>operation</var>, using <var>store</var>,
    <var>range</var>, and <var>count</var> if given.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>records</a> to be retrieved. If
null or not given, an <a>unbounded key range</a> is used. If
<var>count</var> is specified and there are more than <var>count</var>
records in range, only the first <var>count</var> will be retrieved.

<aside class=note>&#9752; The {{IDBObjectStore/getAll()}} method is new in this edition. &#9752;</aside>

The <dfn method for=IDBObjectStore>getAllKeys(<var>query</var>, <var>count</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for retrieving multiple keys from an object store</a>
    as <var>operation</var>, using <var>store</var>, <var>range</var>,
    and <var>count</var> if given.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>records</a> keys to be
retrieved. If null or not given, an <a>unbounded key
range</a> is used. If <var>count</var> is specified and
there are more than <var>count</var> keys in range,
only the first <var>count</var> will be retrieved.

<aside class=note>&#9752; The {{IDBObjectStore/getAllKeys()}} method is new in this edition. &#9752;</aside>


The <dfn method for=IDBObjectStore>count(<var>query</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps to count the records in a range</a> as
    <var>operation</var>, with <var>source</var> and <var>range</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>records</a> keys to be
counted. If null or not given, an <a>unbounded key
range</a> is used.


The <dfn method for=IDBObjectStore>openCursor(<var>query</var>, <var>direction</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Let <var>cursor</var> be a new <a>cursor</a> with <a
    data-lt="cursor.transaction">transaction</a> set to
    <var>transaction</var>, an undefined <a>position</a>,
    <a>direction</a> set to <var>direction</var>, <a>got value
    flag</a> unset, and undefined <a data-lt="cursor.key">key</a> and
    <a data-lt="cursor.value">value</a>. The <a
    data-lt="cursor.source">source</a> of <var>cursor</var> is
    <var>store</var>. The <a>range</a> of <var>cursor</var> is
    <var>range</var>.

7. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for iterating a cursor</a> with <var>cursor</var> as
    <var>operation</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} to use as the <a>cursor</a>'s <a>range</a>.
If null or not given, an <a>unbounded key range</a> is used.


The <dfn method for=IDBObjectStore>openKeyCursor(<var>query</var>, <var>direction</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Let <var>cursor</var> be a new <a>cursor</a> with <a
    data-lt="cursor.transaction">transaction</a> set to
    <var>transaction</var>, an undefined <a>position</a>,
    <a>direction</a> set to <var>direction</var>, <a>got value
    flag</a> unset, and undefined <a data-lt="cursor.key">key</a> and
    <a data-lt="cursor.value">value</a>. The <a
    data-lt="cursor.source">source</a> of <var>cursor</var> is
    <var>store</var>. The <a>range</a> of <var>cursor</var> is
    <var>range</var>. The <a>key only flag</a> of <var>cursor</var> is
    set.

7. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>object store handle</a> as <var>source</var> and
    the <a>steps for iterating a cursor</a> with <var>cursor</var> as
    <var>operation</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} to use as the <a>cursor</a>'s <a>range</a>. If null
or not given, an <a>unbounded key range</a> is used.

<aside class=note>&#9752; The {{IDBObjectStore/openKeyCursor()}} method is new in this edition. &#9752;</aside>


The <dfn method for=IDBObjectStore>createIndex(<var>name</var>, <var>keyPath</var>, <var>options</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>transaction</var> is not an <a>upgrade transaction</a>,
    <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

5. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

6. If an <a>index</a> <a data-lt="index.name">named</a>
    <var>name</var> already exists in <var>store</var>, <a>throw</a> a
    <a>ConstraintError</a> exception.

7. If <var>keyPath</var> is not a <a>valid key path</a>, <a>throw</a>
    a <a>SyntaxError</a> exception.

8. Let <var>unique</var> be set if <var>options</var>'s
    <code>unique</code> member is true, and unset otherwise.

9. Let <var>multiEntry</var> be set if <var>options</var>'s
    <code>multiEntry</code> member is true, and unset otherwise.

10. If <var>keyPath</var> is a sequence and <var>multiEntry</var> is
    set, <a>throw</a> an <a>InvalidAccessError</a> exception.

11. Let <var>index</var> be a new <a>index</a> in <var>store</var>.
    Set <var>index</var>'s <a data-lt="index.name">name</a> to
    <var>name</var> and <a data-lt="index.keyPath">key path</a> to
    <var>keyPath</var>. If <var>unique</var> is set, set
    <var>index</var>'s <a>unique flag</a>. If <var>multiEntry</var> is
    set, set <var>index</var>'s <a>multiEntry flag</a>.

12. Add <var>index</var> to this <a>object store handle</a>'s <a>index
      set</a>.

13. Return a new <a>index handle</a> associated with <var>index</var>
    and this <a>object store handle</a>.


This method creates and returns a new <a>index</a> with the given name
in the <a>object store</a>. Note that this method must only be called
from within an <a>upgrade transaction</a>.

The index that is requested to be created can contain constraints on
the data allowed in the index's <a>referenced</a> object store, such
as requiring uniqueness of the values referenced by the index's
keyPath. If the <a>referenced</a> object store already contains data
which violates these constraints, this MUST NOT cause the
implementation of createIndex to throw an exception or affect what it
returns. The implementation MUST still create and return an
{{IDBIndex}} object, and the implementation MUST <a>queue a
task</a> to abort the <a>upgrade transaction</a> which was used for
the createIndex call.


This method synchronously modifies the {{IDBObjectStore/indexNames}}
property on the {{IDBObjectStore}} instance on which it was called.
Although this method does not return an {{IDBRequest}} object, the
index creation itself is processed as an asynchronous request within
the <a>upgrade transaction</a>.

In some implementations it is possible for the implementation to
asynchronously run into problems creating the index after the
createIndex method has returned. For example in implementations where
metadata about the newly created index is queued up to be inserted
into the database asynchronously, or where the implementation might
need to ask the user for permission for quota reasons. Such
implementations MUST still create and return an {{IDBIndex}}
object, and once the implementation determines that creating the index
has failed, it MUST abort the transaction using the <a>steps for
aborting a transaction</a> using an appropriate error as
<var>error</var>. For example if creating the <a>index</a> failed due
to quota reasons, <a>QuotaExceededError</a> MUST be used as error and
if the index can't be created due to <a>unique flag</a> constraints,
<a>ConstraintError</a> MUST be used as error.

<aside class=example>

The asynchronous creation of indexes is observable in the following example:

<pre class=lang-javascript>
var request1 = objectStore.put({name: "betty"}, 1);
var request2 = objectStore.put({name: "betty"}, 2);
var index = objectStore.createIndex("by_name", "name", {unique: true});
</pre>

At the point where <code>createIndex</code> called, neither of the
<a>requests</a> have executed. When the second request executes, a
duplicate name is created. Since the index creation is considered an
asynchronous <a>request</a>, the index's <a data-lt="unique
flag">uniqueness</a> constraint does not cause the second
<a>request</a> to fail. Instead, the <a>transaction</a> will be <a
data-lt="transaction abort">aborted</a> when the index is created and
the constraint fails.

</aside>

The <dfn method for=IDBObjectStore>index(<var>name</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If <var>transaction</var> has <a data-lt="transaction
    finish">finished</a>, <a>throw</a> an <a>InvalidStateError</a>
    exception.

5. Let <var>index</var> be the <a>index</a> <a
    data-lt="index.name">named</a> <var>name</var> in this <a>object
    store handle</a>'s <a>index set</a> if one exists, or <a>throw</a>
    a <a>NotFoundError</a> exception otherwise.

6. Return an <a>index handle</a> associated with <var>index</var> and
    this <a>object store handle</a>.

<aside class=note>
  Each call to this method on the same {{IDBObjectStore}} instance
  with the same name returns the same {{IDBIndex}} instance.
</aside>

<aside class=note>
  The returned {{IDBIndex}} instance is specific to this
  {{IDBObjectStore}} instance. If this method is called on a
  different {{IDBObjectStore}} instance with the same name, a
  different {{IDBIndex}} instance is returned.
</aside>


The <dfn method for=IDBObjectStore>deleteIndex(<var>name</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.transaction">transaction</a>.

2. Let <var>store</var> be this <a>object store handle</a>'s <a
    data-lt="objectStoreHandle.objectStore">object store</a>.

3. If <var>transaction</var> is not an <a>upgrade transaction</a>,
    <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>store</var> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

5. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

6. Let <var>index</var> be the <a>index</a> <a
    data-lt="index.name">named</a> <var>name</var> in <var>store</var>
    if one exists, or <a>throw</a> a <a>NotFoundError</a> exception
    otherwise.

7. Remove <var>index</var> from this <a>object store handle</a>'s
    <a>index set</a>.

8. Destroy <var>index</var>.

This method destroys the <a>index</a> with the given name in the
<a>object store</a>. Note that this method must only be called from
within an <a>upgrade transaction</a>.

This method synchronously modifies the {{IDBObjectStore/indexNames}}
property on the {{IDBObjectStore}} instance on which it was called.
Although this method does not return an {{IDBRequest}} object, the
index destruction itself is processed as an asynchronous request
within the <a>upgrade transaction</a>.


<!-- ============================================================ -->
<h4 id=index-interface>The <code>IDBIndex</code> interface</h4>
<!-- ============================================================ -->

The {{IDBIndex}} interface represents an <a>index handle</a>.


<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBIndex {
  attribute DOMString      name;
  readonly    attribute IDBObjectStore objectStore;
  readonly    attribute any            keyPath;
  readonly    attribute boolean        multiEntry;
  readonly    attribute boolean        unique;

  IDBRequest get(any query);
  IDBRequest getKey(any query);
  IDBRequest getAll(optional any query, [EnforceRange] optional unsigned long count);
  IDBRequest getAllKeys(optional any query, [EnforceRange] optional unsigned long count);
  IDBRequest count(optional any query);

  IDBRequest openCursor(optional any query, optional IDBCursorDirection direction = "next");
  IDBRequest openKeyCursor(optional any query, optional IDBCursorDirection direction = "next");
};
</pre>


The {{IDBIndex/name}}
attribute's getter must return this <a>index handle</a>'s <a
data-lt="index.name">name</a>.

<aside class=note>
  As long as the <a>transaction</a> has not <a data-lt="transaction
  finish">finished</a>, this is the same as the associated
  <a>index</a>'s <a data-lt="index.name">name</a>.

  Once the <a>transaction</a> has <a data-lt="transaction
  finish">finished</a>, this attribute will not reflect changes made
  with a later <a>upgrade transaction</a>.
</aside>


The {{IDBIndex/name}} attribute's setter must run these steps:

1. Let <var>name</var> be the given value.

2. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

3. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

4. If <var>transaction</var> is not an <a>upgrade transaction</a>,
    <a>throw</a> an <a>InvalidStateError</a> exception.

5. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

6. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

7. If <var>index</var>'s <a data-lt="index.name">name</a> is equal to
    <var>name</var>, terminate these steps.

8. If an <a>index</a> <a data-lt="index.name">named</a>
    <var>name</var> already exists in <var>index</var>'s <a>object
    store</a>, <a>throw</a> a <a>ConstraintError</a> exception.

9. Set <var>index</var>'s <a data-lt="index.name">name</a> to
    <var>name</var>.

10. Set this <a>index handle</a>'s <a
    data-lt="indexHandle.name">name</a> to <var>name</var>.

<aside class=note>&#9752; The {{IDBIndex/name}} attribute's setter is new in this edition. &#9752;</aside>


The {{IDBIndex/objectStore}} attribute's getter
must return this <a>index handle</a>'s <a
data-lt="indexHandle.objectStoreHandle">object store handle</a>.

The {{IDBIndex/keyPath}} attribute's getter must return this <a>index
handle</a>'s <a data-lt="indexHandle.index">index</a>'s <a
data-lt="objectStore.keyPath">key path</a>.

The conversion is done following the normal [[!WEBIDL]] binding logic
for <a>DOMString</a> and <a>sequence&lt;DOMString&gt;</a> values, as
appropriate.

The returned value is not the same instance that was used when the
<a>index</a> was created. However, if this attribute returns an object
(specifically an <a>Array</a>), it returns the same object instance
every time it is inspected. Changing the properties of the object has
no effect on the <a>index</a>.

The {{IDBIndex/multiEntry}} attribute's getter must return true if
this <a>index handle</a>'s <a data-lt="indexHandle.index">index</a>'s
<a>multiEntry flag</a> is set, and false otherwise.

The {{IDBIndex/unique}} attribute's getter must return true if this
<a>index handle</a>'s <a data-lt="indexHandle.index">index</a>'s
<a>unique flag</a> is set, and false otherwise.

The <dfn method for=IDBIndex>get(<var>query</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

3. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var> and
    <var>null disallowed flag</var> set. If this throws an exception,
    <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
      return the {{IDBRequest}} created by these steps. The steps
      are run with this <a>index handle</a> as <var>source</var> and
      the <a>steps for retrieving a referenced value from an index</a>
      as <var>operation</var>, using <var>index</var> and
      <var>range</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>record</a> to be retrieved. If a
range is specified, the method retrieves the first existing record in
that range.


<aside class=note>
  This method produces the same result if a record with the given key
  doesn't exist as when a record exists, but has undefined as value.
  If you need to tell the two situations apart, you can use
  {{IDBIndex/openCursor()}} with the same key. This will return a cursor
  with undefined as value if a record exists, or no cursor if no such
  record exists.
</aside>


The <dfn method for=IDBIndex>getKey(<var>query</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

3. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var> and
    <var>null disallowed flag</var> set. If this throws an exception,
    <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps
    are run with this <a>index handle</a> as <var>source</var> and
    the <a>steps for retrieving a value from an index</a> as
    <var>operation</var>, using <var>index</var> and
    <var>range</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>record</a> key to be retrieved.
If a range is specified, the method retrieves the first existing key
in that range.


The <dfn method for=IDBIndex>getAll(<var>query</var>, <var>count</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

3. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>index handle</a> as <var>source</var> and the
    <a>steps for retrieving multiple referenced values from an
    index</a> as <var>operation</var>, using <var>index</var>,
    <var>range</var>, and <var>count</var> if given.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>records</a> to be retrieved. If
null or not given, an <a>unbounded key range</a> is used. If
<var>count</var> is specified and there are more than <var>count</var>
records in range, only the first <var>count</var> will be retrieved.

<aside class=note>&#9752; The {{IDBIndex/getAll()}} method is new in this edition. &#9752;</aside>


The <dfn method for=IDBIndex>getAllKeys(<var>query</var>, <var>count</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

3. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps
    are run with this <a>index handle</a> as <var>source</var> and
    the <a>steps for retrieving multiple values from an index</a>
    as <var>operation</var>, using <var>index</var>,
    <var>range</var>, and <var>count</var> if given.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>records</a> keys to be
retrieved. If null or not given, an <a>unbounded key range</a> is
used. If <var>count</var> is specified and there are more than
<var>count</var> keys in range, only the first <var>count</var> will
be retrieved.

<aside class=note>&#9752; The {{IDBIndex/getAllKeys()}} method is new in this edition. &#9752;</aside>


The <dfn method for=IDBIndex>count(<var>query</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

3. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.


6. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>index handle</a> as <var>source</var> and the
    <a>steps to count the records in a range</a> as
    <var>operation</var>, with <a>index</a> as <var>source</var> and
    <var>range</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} identifying the <a>records</a> keys to be counted.
If null or not given, an <a>unbounded key range</a> is used.


The <dfn method for=IDBIndex>openCursor(<var>query</var>, <var>direction</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

3. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

6. Let <var>cursor</var> be a new <a>cursor</a> with <a
    data-lt="cursor.transaction">transaction</a> set to
    <var>transaction</var>, an undefined <a>position</a>,
    <a>direction</a> set to <var>direction</var>, <a>got value
    flag</a> unset, and undefined <a data-lt="cursor.key">key</a> and
    <a data-lt="cursor.value">value</a>. The <a
    data-lt="cursor.source">source</a> of <var>cursor</var> is
    <var>index</var>. The <a>range</a> of <var>cursor</var> is
    <var>range</var>.

7. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>index handle</a> as <var>source</var> and the
    <a>steps for iterating a cursor</a> with <var>cursor</var> as
    <var>operation</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} to use as the <a>cursor</a>'s <a>range</a>. If null
or not given, an <a>unbounded key range</a> is used.


The <dfn method for=IDBIndex>openKeyCursor(<var>query</var>, <var>direction</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.transaction">transaction</a>.

2. Let <var>index</var> be this <a>index handle</a>'s <a
    data-lt="indexHandle.index">index</a>.

3. If <var>index</var> or <var>index</var>'s <a>object store</a> has
    been deleted, <a>throw</a> an <a>InvalidStateError</a> exception.

4. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

5. Let <var>range</var> be the result of running the steps to
    <a>convert a value to a key range</a> with <var>query</var>. If
    this throws an exception, <a>rethrow</a> it.

7. Let <var>cursor</var> be a new <a>cursor</a> with <a
    data-lt="cursor.transaction">transaction</a> set to
    <var>transaction</var>, an undefined <a>position</a>,
    <a>direction</a> set to <var>direction</var>, <a>got value
    flag</a> unset, and undefined <a data-lt="cursor.key">key</a> and
    <a data-lt="cursor.value">value</a>. The <a
    data-lt="cursor.source">source</a> of <var>cursor</var> is
    <var>index</var>. The <a>range</a> of <var>cursor</var> is
    <var>range</var>. The <a>key only flag</a> of <var>cursor</var> is
    set.

8. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>index handle</a> as <var>source</var> and the
    <a>steps for iterating a cursor</a> with <var>cursor</var> as
    <var>operation</var>.

The <var>query</var> parameter may be a <a>key</a> or an
{{IDBKeyRange}} to use as the <a>cursor</a>'s <a>range</a>. If null
or not given, an <a>unbounded key range</a> is used.


<!-- ============================================================ -->
<h4 id=keyrange>The <code>IDBKeyRange</code> interface</h4>
<!-- ============================================================ -->

The {{IDBKeyRange}} interface represents a
<a>key range</a>.

<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBKeyRange {
  readonly    attribute any     lower;
  readonly    attribute any     upper;
  readonly    attribute boolean lowerOpen;
  readonly    attribute boolean upperOpen;

  // Static construction methods:
  static IDBKeyRange only(any value);
  static IDBKeyRange lowerBound(any lower, optional boolean open = false);
  static IDBKeyRange upperBound(any upper, optional boolean open = false);
  static IDBKeyRange bound(any lower, any upper, optional boolean lowerOpen = false, optional boolean upperOpen = false);

  boolean includes(any key);
};
</pre>

The {{IDBKeyRange/lower}} attribute's getter must return result of
running the steps to <a>convert a key to a value</a> with the <a>lower
bound</a> if it is not null, or undefined otherwise.

The {{IDBKeyRange/upper}} attribute's getter must return the result of
running the steps to <a>convert a key to a value</a> with the <a>upper
bound</a> if it is not null, or undefined otherwise.

The {{IDBKeyRange/lowerOpen}} attribute's getter must return true if
the <a>lower open flag</a> is set, and false otherwise.

The {{IDBKeyRange/upperOpen}} attribute's getter must return true if
the <a>upper open flag</a> is set, and false otherwise.

The <dfn method for=IDBKeyRange>only(<var>value</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>key</var> be the result of running the steps to <a>convert
    a value to a key</a> with <var>value</var>. If this throws an an
    exception, <a>rethrow</a> it.

2. If <var>key</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

3. Create and return a new <a>key range</a> <a>containing only</a>
    <var>key</var>.


The <dfn method for=IDBKeyRange>lowerBound(<var>lower</var>, <var>lowerOpen</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>lowerKey</var> be the result of running the steps to
    <a>convert a value to a key</a> with <var>lower</var>. If this
    throws an an exception, <a>rethrow</a> it.

2. If <var>lowerKey</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

3. Create and return a new <a>key range</a> with
    <a>lower bound</a> set to <var>lowerKey</var>,
    <a>lower open flag</a> set if <var>lowerOpen</var> is true,
    <a>upper bound</a> set to null and
    <a>upper open flag</a> set.


The <dfn method for=IDBKeyRange>upperBound(<var>upper</var>, <var>upperOpen</var>)</dfn> method, when invoked, must run these steps:

1. Let
    <var>upperKey</var> be the result of running the steps to <a>convert a value to a key</a> with <var>upper</var>.
    If this throws an an exception, <a>rethrow</a> it.

2. If <var>upperKey</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

3. Create and return a new <a>key range</a> with
    <a>lower bound</a> set to null,
    <a>lower open flag</a> set,
    <a>upper bound</a> set if <var>upperKey</var>, and
    <a>upper open flag</a> set to <var>upperOpen</var>.

The <dfn method for=IDBKeyRange>bound(<var>lower</var>, <var>upper</var>, <var>lowerOpen</var>, <var>upperOpen</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>lowerKey</var> be the result of running the steps to
    <a>convert a value to a key</a> with <var>lower</var>. If this
    throws an an exception, <a>rethrow</a> it.

2. If <var>lowerKey</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

3. Let <var>upperKey</var> be the result of running the steps to
    <a>convert a value to a key</a> with <var>upper</var>. If this
    throws an an exception, <a>rethrow</a> it.

4. If <var>upperKey</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

5. If <var>lowerKey</var> is <a>greater than</a> <var>upperKey</var>,
    <a>throw</a> a <a>DataError</a> exception.

6. Create and return a new <a>key range</a> with
    <a>lower bound</a> set to <var>lowerKey</var>,
    <a>lower open flag</a> set if <var>lowerOpen</var> is true,
    <a>upper bound</a> set to <var>upperKey</var> and
    <a>upper open flag</a> set if <var>upperOpen</var> is true.


The <dfn method for=IDBKeyRange>includes(<var>key</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>k</var> be the result of running the steps to <a>convert a
    value to a key</a> with <var>key</var>. If this throws an an
    exception, <a>rethrow</a> it.

2. If <var>k</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

3. Return true if <var>k</var> is <a data-lt="in a key range">in</a>
    this range, and false otherwise.

<aside class=note>&#9752; The {{IDBKeyRange/includes()}} method is new in this edition. &#9752;</aside>


<!-- ============================================================ -->
<h4 id=cursor-interface>The <code>IDBCursor</code> interface</h4>
<!-- ============================================================ -->

<a>Cursor</a> objects implement the {{IDBCursor}} interface. There
is only ever one {{IDBCursor}} instance representing a given
<a>cursor</a>. There is no limit on how many cursors can be used at
the same time.


<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBCursor {
  readonly    attribute (IDBObjectStore or IDBIndex) source;
  readonly    attribute IDBCursorDirection           direction;
  readonly    attribute any                          key;
  readonly    attribute any                          primaryKey;

  void       advance([EnforceRange] unsigned long count);
  void       continue(optional any key);
  void       continuePrimaryKey(any key, any primaryKey);

  IDBRequest update(any value);
  IDBRequest delete();
};

enum IDBCursorDirection {
  "next",
  "nextunique",
  "prev",
  "prevunique"
};
</pre>

The {{IDBCursor/source}} attribute's getter must return the <a
data-lt="cursor.source">source</a> of this <a>cursor</a>. This
attribute never returns null or throws an exception, even if the
cursor is currently being iterated, has iterated past its end, or its
<a>transaction</a> is not <a>active</a>.

The {{IDBCursor/direction}} attribute's getter must return the <a>direction</a>
of the <a>cursor</a>.

The {{IDBCursor/key}} attribute's getter must return the result of running the
steps to <a>convert a key to a value</a> with the cursor's current <a
data-lt="cursor.key">key</a>. Note that if this property returns an
object (e.g. a <a>Date</a> or <a>Array</a>), it returns the same
object instance every time it is inspected, until the cursor's <a
data-lt="cursor.key">key</a> is changed. This means that if the object
is modified, those modifications will be seen by anyone inspecting the
value of the cursor. However modifying such an object does not modify
the contents of the database.

The {{IDBCursor/primaryKey}} attribute's getter must return the result of
running the steps to <a>convert a key to a value</a> with the cursor's
current <a>effective key</a>. Note that if this property returns an
object (e.g. a <a>Date</a> or <a>Array</a>), it returns the same
object instance every time it is inspected, until the cursor's
<a>effective key</a> is changed. This means that if the object is
modified, those modifications will be seen by anyone inspecting the
value of the cursor. However modifying such an object does not modify
the contents of the database.

The <dfn method for=IDBCursor>update(<var>value</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>cursor</a>'s <a
    data-lt="cursor.transaction">transaction</a>.

2. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

3. If <var>transaction</var> is a <a>read-only transaction</a>,
    <a>throw</a> a <a>ReadOnlyError</a> exception.

4. If the cursor's <a data-lt="cursor.source">source</a> or
    <a>effective object store</a> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

5. If this cursor's <a>got value flag</a> is unset, indicating that
    the cursor is being iterated or has iterated past its end,
    <a>throw</a> an <a>InvalidStateError</a> exception.

6. If this cursor's <a>key only flag</a> is set, <a>throw</a> an
    <a>InvalidStateError</a> exception.

7. Let <var>clone</var> be <a>structured clone</a> of <var>value</var>. If this
    throws an exception, <a>rethrow</a> the exception.

8. If the <a>effective object store</a> of this cursor uses <a>in-line
    keys</a>, run these substeps:

    1. Let <var>kpk</var> be the result of running the steps to
        <a>extract a key from a value using a key path</a> with
        <var>clone</var> and the <a data-lt="objectStore.keyPath">key
        path</a> of the <a>effective object store</a>. If this throws
        an exception, <a>rethrow</a> it.

    2. If <var>kpk</var> is failure, invalid, or not <a>equal to</a>
        the cursor's <a>effective key</a>, <a>throw</a> a
        <a>DataError</a> exception.

9. Run <a>steps for asynchronously executing a request</a> and return
    the {{IDBRequest}} created by these steps. The steps are run
    with this <a>cursor</a> as <var>source</var> and the <a>steps for
    storing a record into an object store</a> as <var>operation</var>,
    using this cursor's <a>effective object store</a> as
    <var>store</var>, the <var>clone</var> as <var>value</var>, this
    cursor's <a>effective key</a> as <var>key</var>, and with the
    <var>no-overwrite flag</var> unset.


<aside class=note>
  A result of running the <a>steps for storing a record into an object
  store</a> is that if the record has been deleted since the cursor
  moved to it, a new record will be created.
</aside>


The <dfn method for=IDBCursor>advance(<var>count</var>)</dfn> method, when invoked, must run these steps:

1. If <var>count</var> is 0 (zero), <a>throw</a> a <a>TypeError</a>.

2. Let <var>transaction</var> be this <a>cursor</a>'s <a
    data-lt="cursor.transaction">transaction</a>.

3. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

4. If the cursor's <a data-lt="cursor.source">source</a> or
    <a>effective object store</a> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

5. If this cursor's <a>got value flag</a> is unset, indicating that
    the cursor is being iterated or has iterated past its end,
    <a>throw</a> an <a>InvalidStateError</a> exception.

7. Unset the <a>got value flag</a> on the cursor.

8. Let <var>request</var> be the <a>request</a> created when this
    <a>cursor</a> was created.

9. Unset the <a>done flag</a> on <var>request</var>.

10. Run the <a>steps for asynchronously executing a request</a> with
    the cursor's <a data-lt="cursor.source">source</a> as
    <var>source</var> and the <a>steps for iterating a cursor</a> with
    this <a>cursor</a> and <var>count</var>, and <var>request</var>.


<aside class=note>
  Calling this method more than once before new cursor data has been
  loaded - for example, calling <code>advance()</code> twice from the
  same onsuccess handler - results in an <a>InvalidStateError</a>
  exception being thrown on the second call because the cursor's
  <a>got value flag</a> has been unset.
</aside>

The <dfn method for=IDBCursor>continue(<var>key</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>cursor</a>'s <a
    data-lt="cursor.transaction">transaction</a>.

2. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

3. If the cursor's <a data-lt="cursor.source">source</a> or
    <a>effective object store</a> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If this cursor's <a>got value flag</a> is unset, indicating that
    the cursor is being iterated or has iterated past its end,
    <a>throw</a> an <a>InvalidStateError</a> exception.

5. If <var>key</var> is given, run these substeps:

    1. Let <var>r</var> be the result of running the steps to
        <a>convert a value to a key</a> with <var>key</var>. If this
        throws an exception, <a>rethrow</a> it.

    2. If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a>
        exception.

    3. Let <var>key</var> be <var>r</var>.

    4. If <var>key</var> is <a>less than</a> or <a>equal to</a> this
        cursor's <a>position</a> and this cursor's <a>direction</a> is
        "<code>next</code>" or "<code>nextunique</code>", <a>throw</a>
        a <a>DataError</a> exception.

    5. If <var>key</var> is <a>greater than</a> or <a>equal to</a>
        this cursor's <a>position</a> and this cursor's
        <a>direction</a> is "<code>prev</code>" or
        "<code>prevunique</code>", <a>throw</a> a <a>DataError</a>
        exception.

6. Unset the <a>got value flag</a> on the cursor.

7. Let <var>request</var> be the <a>request</a> created when this
    <a>cursor</a> was created.

8. Unset the <a>done flag</a> on <var>request</var>.

9. Run the <a>steps for asynchronously executing a request</a> with
    the cursor's <a data-lt="cursor.source">source</a> as
    <var>source</var> and the <a>steps for iterating a cursor</a> with
    this <a>cursor</a> and <var>key</var> (if given), and
    <var>request</var>.


<aside class=note>
  Calling this method more than once before new cursor data has been
  loaded - for example, calling <code>continue()</code> twice from the
  same onsuccess handler - results in an <a>InvalidStateError</a>
  exception being thrown on the second call because the cursor's
  <a>got value flag</a> has been unset.
</aside>


The <dfn method for=IDBCursor>continuePrimaryKey(<var>key</var>, <var>primaryKey</var>)</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>cursor</a>'s <a
    data-lt="cursor.transaction">transaction</a>.

2. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

3. If the cursor's <a data-lt="cursor.source">source</a> or
    <a>effective object store</a> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

4. If this cursor's <a data-lt="cursor.source">source</a> is not an
    <a>index</a> <a>throw</a> an <a>InvalidAccessError</a> exception.

5. If this cursor's <a>direction</a> is not "<code>next</code>" or
    "<code>prev</code>", <a>throw</a> an <a>InvalidAccessError</a>
    exception.

6. If this cursor's <a>got value flag</a> is unset, indicating that
    the cursor is being iterated or has iterated past its end,
    <a>throw</a> an <a>InvalidStateError</a> exception.

7. Let <var>r</var> be the result of running the steps to <a>convert a
    value to a key</a> with <var>key</var>. If this throws an
    exception, <a>rethrow</a> it.

8. If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

9. Let <var>key</var> be <var>r</var>.

10. Let <var>r</var> be the result of running the steps to <a>convert
     a value to a key</a> with <var>primaryKey</var>. If this throws
     an exception, <a>rethrow</a> it.

11. If <var>r</var> is invalid, <a>throw</a> a <a>DataError</a>
    exception.

12. Let <var>primaryKey</var> be <var>r</var>.

13. If <var>key</var> is <a>less than</a> or <a>equal to</a> this
    cursor's <a>position</a> and this cursor's <a>direction</a> is
    "<code>next</code>" or "<code>nextunique</code>", <a>throw</a> a
    <a>DataError</a> exception.

14. If <var>key</var> is <a>greater than</a> or <a>equal to</a> this
    cursor's <a>position</a> and this cursor's <a>direction</a> is
    "<code>prev</code>" or "<code>prevunique</code>", <a>throw</a> a
    <a>DataError</a> exception.

15. If <var>key</var> is <a>equal to</a> this cursor's <a>position</a>
    and <var>primaryKey</var> is <a>less than</a> or <a>equal to</a>
    this cursor's <a>object store position</a> and this cursor's
    <a>direction</a> is "<code>next</code>" or
    "<code>nextunique</code>", <a>throw</a> a <a>DataError</a>
    exception.

16. If <var>key</var> is <a>equal to</a> this cursor's <a>position</a>
    and <var>primaryKey</var> is <a>greater than</a> or <a>equal
    to</a> this cursor's <a>object store position</a> and this
    cursor's <a>direction</a> is "<code>prev</code>" or
    "<code>prevunique</code>", <a>throw</a> a <a>DataError</a>
    exception.

17. Unset the <a>got value flag</a> on the cursor.

18. Let <var>request</var> be the <a>request</a> created when this
    <a>cursor</a> was created.

19. Unset the <a>done flag</a> on <var>request</var>.

20. Run the <a>steps for asynchronously executing a request</a> with
    the cursor's <a data-lt="cursor.source">source</a> as
    <var>source</var> and the <a>steps for iterating a cursor</a> with
    this <a>cursor</a>, <var>key</var>, <var>primaryKey</var>, and
    <var>request</var>.

<aside class=note>&#9752; The {{IDBCursor/continuePrimaryKey()}} method is new in this edition. &#9752;</aside>

<aside class=note>
  Calling this method more than once before new cursor data has been
  loaded - for example, calling <code>continuePrimaryKey()</code>
  twice from the same onsuccess handler - results in an
  <a>InvalidStateError</a> exception being thrown on the second call
  because the cursor's <a>got value flag</a> has been unset.
</aside>


The <dfn method for=IDBCursor>delete()</dfn> method, when invoked, must run these steps:

1. Let <var>transaction</var> be this <a>cursor</a>'s <a
    data-lt="cursor.transaction">transaction</a>.

2. If <var>transaction</var> is not <a>active</a>, <a>throw</a> a
    <a>TransactionInactiveError</a> exception.

3. If <var>transaction</var> is a <a>read-only transaction</a>,
    <a>throw</a> a <a>ReadOnlyError</a> exception.

4. If the cursor's <a data-lt="cursor.source">source</a> or
    <a>effective object store</a> has been deleted, <a>throw</a> an
    <a>InvalidStateError</a> exception.

5. If this cursor's <a>got value flag</a> is unset, indicating that
    the cursor is being iterated or has iterated past its end,
    <a>throw</a> an <a>InvalidStateError</a> exception.

6. If this cursor's <a>key only flag</a> is set, <a>throw</a> an
    <a>InvalidStateError</a> exception.

7. Run the <a>steps for asynchronously executing a request</a> and
    return the {{IDBRequest}} created by these steps. The steps are
    run with this <a>cursor</a> as <var>source</var> and the <a>steps
    for deleting records from an object store</a> as
    <var>operation</var>, using this cursor's <a>effective object
    store</a> and <a>effective key</a> as <var>store</var> and
    <var>key</var> respectively.

A <a>cursor</a> that has the <a>key only flag</a> unset implements the {{IDBCursorWithValue}} interface as well.


<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBCursorWithValue : IDBCursor {
  readonly    attribute any value;
};
</pre>

The {{IDBCursorWithValue/value}} attribute's getter must return the
cursor's current <a data-lt="cursor.value">value</a>.

Note that if this property returns an object, it returns the same
object instance every time it is inspected, until the cursor's <a
data-lt="cursor.value">value</a> is changed. This means that if the
object is modified, those modifications will be seen by anyone
inspecting the value of the cursor. However modifying such an object
does not modify the contents of the database.


<!-- ============================================================ -->
<h4 id=transaction>The <code>IDBTransaction</code> interface</h4>
<!-- ============================================================ -->

<a>Transaction</a> objects implement the following interface:

<pre class="idl">
[Exposed=(Window,Worker)]
interface IDBTransaction : EventTarget {
  readonly    attribute DOMStringList      objectStoreNames;
  readonly    attribute IDBTransactionMode mode;
  readonly    attribute IDBDatabase        db;
  readonly    attribute DOMException       error;

  IDBObjectStore objectStore(DOMString name);
  void           abort();

  // Event handlers:
  attribute EventHandler       onabort;
  attribute EventHandler       oncomplete;
  attribute EventHandler       onerror;
};

enum IDBTransactionMode {
  "readonly",
  "readwrite",
  "versionchange"
};
</pre>

The {{IDBTransaction/objectStoreNames}} attribute's getter must run
the following steps:

1. If this <a>transaction</a> is an <a>upgrade transaction</a>, return a
    <a>sorted list</a> of the <a data-lt="objectStore.name">names</a>
    of the <a>object stores</a> in this <a>transaction</a>'s
    <a>connection</a>'s <a>object store set</a>.

2. Otherwise, return a <a>sorted list</a> of the <a data-lt="objectStore.name">names</a>
    of the <a>object stores</a> in this <a>transaction</a>'s <a>scope</a>.


<aside class=note>&#9752; The {{IDBTransaction/objectStoreNames}} attribute is new in this edition. &#9752;</aside>

<aside class=note>
  The contents of each list returned by this attribute does not
  change, but subsequent calls to this attribute during an <a>upgrade
  transaction</a> may return lists with different contents as
  <a>object stores</a> are created and deleted.
</aside>

The {{IDBTransaction/mode}} attribute's getter must return the
<a>mode</a> of the <a>transaction</a>.

The {{IDBTransaction/db}} attribute's getter must return the
<a>database</a> <a>connection</a> of which this <a>transaction</a> is
a part.

The {{IDBTransaction/error}} attribute's getter must return this
<a>transaction</a>'s <a data-lt="transaction error">error</a>, or null
if none.

<aside class=note>
  If this <a>transaction</a> was aborted due to a failed
  <a>request</a>, this will be the same as the <a>request</a>'s <a
  data-lt="request.error">error</a>.

  If this <a>transaction</a> was aborted due to an uncaught exception
  in a event handler, the error will be <a>AbortError</a>.

  If the <a>transaction</a> was aborted due to an error while
  committing, it will reflect the reason for the failure (e.g.
  <a>QuotaExceededError</a>, <a>ConstraintError</a>, or
  <a>UnknownError</a>).
</aside>


The <dfn method for=IDBTransaction>objectStore(<var>name</var>)</dfn> method, when invoked, must run these steps:

1. If <var>transaction</var> has <a data-lt="transaction
    finish">finished</a>, <a>throw</a> an <a>InvalidStateError</a>
    exception.

2. Let <var>store</var> be the <a>object store</a> <a
    data-lt="objectStore.name">named</a> <var>name</var> in this
    <a>transaction</a>'s <a>scope</a>, or <a>throw</a> a
    <a>NotFoundError</a> exception if none.

3. Return an <a>object store handle</a> associated with
    <var>store</var> and this <a>transaction</a>.

<aside class=note>
  Each call to this method on the same {{IDBTransaction}} instance
  with the same name returns the same {{IDBObjectStore}} instance.
</aside>

<aside class=note>
  The returned {{IDBObjectStore}} instance is specific to this
  {{IDBTransaction}}. If this method is called on a different
  {{IDBTransaction}}, a different {{IDBObjectStore}} instance is
  returned.
</aside>


The <dfn method for=IDBTransaction>abort()</dfn> method, when invoked, must run these steps:

1. If this <a>transaction</a> is <a data-lt="transaction finish">finished</a>,
    <a>throw</a> an <a>InvalidStateError</a> exception.

2. Unset the <a>transaction</a>'s <a>active flag</a> and run the
    <a>steps for aborting a transaction</a> with null as <var>error</var>.


The {{IDBTransaction/onabort}} attribute is the event handler for the
<code>abort</code> event.

The {{IDBTransaction/oncomplete}} attribute is the event handler for
the <code>complete</code> event.

The {{IDBTransaction/onerror}} attribute is the event handler for the
<code>error</code> event.

<aside class=note>
  To determine if a <a>transaction</a> has completed successfully,
  listen to the <a>transaction</a>'s <code>complete</code> event
  rather than the <code>success</code> event of a particular
  <a>request</a>, because the <a>transaction</a> may still fail after
  the <code>success</code> event fires.
</aside>



<!-- ============================================================ -->
<h3 id=algorithms>Algorithms</h3>
<!-- ============================================================ -->

<!-- ============================================================ -->
<h4 id=opening>Opening a database</h4>
<!-- ============================================================ -->

The <dfn>steps for opening a database</dfn> are defined in the following steps. The algorithm in these steps
takes four arguments:
the <var>origin</var> which requested the <a>database</a> to be opened,
a database <var>name</var>,
a database <var>version</var>,
and a <var>request</var>.


<ol class=algorithm>
<li>
Let <var>db</var> be the <a>database</a> <a data-lt="database.name">named</a> <var>name</var> in the
origin <var>origin</var>, or null otherwise.

<li>
If <var>db</var> is not null, run these substeps:
<ol>
<li>Wait until the following conditions are all fulfilled:
<ul>
<li>
No already existing <a>connections</a> to <var>db</var>, have
non-<a data-lt="transaction finish">finished</a> <a>upgrade transaction</a>.

<li>
If <var>db</var> has its <a>delete pending flag</a> set, wait until <var>db</var> has
been deleted.

</ul>
<aside class=note>
If several requests with the same <var>origin</var> and <var>name</var> are waiting due to the above conditions,
and those connections have a higher version than the database's current version, then once any of
those connections can proceed to the next step in this algorithm it will immediately start
an <a>upgrade transaction</a>. This prevents the other connections from proceeding until that
<a>upgrade transaction</a> is finished.
</aside>

<li>
If <var>db</var> was deleted, let <var>db</var> be null.

</ol>

<li>
If <var>version</var> is undefined,
let <var>version</var> be 1 if <var>db</var> is null, or <var>db</var>'s <a>version</a> otherwise.

<li>
If <var>db</var> is null, let <var>db</var> be a new <a>database</a> with
<a data-lt="database.name">name</a> <var>name</var>, <a>version</a> 0 (zero) as <a>version</a>,
and with no <a>object stores</a>.

<li>
If <var>db</var>'s <a>version</a> is greater than <var>version</var>, abort these steps and return
a new <a>VersionError</a>.

<li>
Let <var>connection</var> be a new <a>connection</a> to <var>db</var>.

<li>
Set <var>connection</var>'s <a data-lt="connection.version">version</a> to <var>version</var>.

<li>
If <var>db</var>'s <a>version</a> is less than <var>version</var>, run these substeps:
<ol>
<li>
Run the <a>steps for running an upgrade transaction</a>
using <var>connection</var>, <var>version</var> and <var>request</var>.

<li>
If <var>connection</var> was <a data-lt="database close">closed</a>,
create and return a new <a>AbortError</a> exception and abort these steps.

<li>
If the <a>upgrade transaction</a> was aborted,
run the <a>steps for closing a database connection</a> with <var>connection</var>,
create and return a new <a>AbortError</a> exception and abort these steps.

</ol>

<li>
Return <var>connection</var>.

</ol>



<!-- ============================================================ -->
<h4 id=closing-connection>Closing a database</h4>
<!-- ============================================================ -->

The <dfn>steps for closing a database connection</dfn> are as follows.
These steps take two arguments, a <var>connection</var> object, and an
optional <var>forced flag</var>.

<ol class=algorithm>
<li>
Set the <a>close pending flag</a> of <var>connection</var>.

<li>
If the <var>forced flag</var> is set, then for each <var>transaction</var> <a data-lt="transaction create">created</a>
using <var>connection</var> run the <a>steps for aborting a transaction</a> with
<var>transaction</var> and newly created <a>AbortError</a> exception.

<li>
Wait for all transactions <a data-lt="transaction create">created</a> using <var>connection</var> to complete.
Once they are complete, <var>connection</var> is <a data-lt="database close">closed</a>.

<li>
If the <var>forced flag</var> is set, then fire a <code>close</code> event at
<var>connection</var>. The event MUST use the <a>Event</a> interface and have its
type set to "<code>close</code>". The event MUST NOT bubble or be cancelable.

<aside class=note>&#9752; This behavior is new in this edition. &#9752;</aside>

</ol>
<aside class=note>
Once the <a>close pending flag</a> has been set no new transactions can be
<a data-lt="transaction create">created</a> using <var>connection</var>. All methods that
<a data-lt="transaction create">create</a> transactions first check the <a>close pending flag</a> first and
throw an exception if it is set.
</aside>
<aside class=note>
Once the <a>connection</a> is closed, this can unblock the <a>steps for running an upgrade
transaction</a>, and the <a>steps for deleting a database</a>, which <a href="#delete-close-block">both</a>
<a href="#version-change-close-block">wait</a> for <a>connections</a> to a given <a>database</a> to be closed
before continuing.
</aside>


<!-- ============================================================ -->
<h4 id=deleting-a-database>Deleting a database</h4>
<!-- ============================================================ -->

The <dfn>steps for deleting a database</dfn> are as follows.
The algorithm in these steps takes three arguments:
the <var>origin</var> that requested the <a>database</a> to be deleted,
a database <var>name</var>,
and a <var>request</var>.

<ol class=algorithm>
<li>
Let <var>db</var> be the <a>database</a> with the given name from the origin <var>origin</var>,
if one exists. Otherwise, return 0 (zero).

<li>
Set <var>db</var>'s <a>delete pending flag</a>.

<li>
Let <var>openConnections</var> be the set of all <a>connections</a>
associated with <var>db</var>.

<li>
For each <var>entry</var> in <var>openConnections</var> that does not have its <a>close pending flag</a> set,
<a>fire a version change event</a> named <code>versionchange</code>
at <var>entry</var> with <var>db</var>'s <a>version</a> and null.
<aside class=note>
Firing this event might cause one or more of the other objects in <var>openConnections</var> to be closed, in which case
the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
</aside>

<li>
If any of the <a>connections</a> in <var>openConnections</var> are still not closed,
<a>fire a version change event</a> named <code>blocked</code>
at <var>request</var> with <var>db</var>'s <a>version</a> and null.

<li id="delete-close-block">
Wait until all <a>connections</a> in <var>openConnections</var> are <a data-lt="database close">closed</a> and all of
their transactions are <a data-lt="transaction finish">finished</a>.

<li>
Let <var>version</var> be <var>db</var>'s <a>version</a>.

<li>
Delete <var>db</var>.

<li>
Return <var>version</var>.

</ol>


<!-- ============================================================ -->
<h4 id=commit-transaction>Steps for committing a transaction</h4>
<!-- ============================================================ -->

When taking the <dfn>steps for committing a transaction</dfn> the implementation MUST
execute the following algorithm. This algorithm takes one argument, the <var>transaction</var> to commit.

<ol class=algorithm>
<li>
All the changes made to the <a>database</a> by <var>transaction</var> are written to the <a>database</a>.

<li>
If an error occurs while writing the changes to the <a>database</a>, abort the transaction by following
the <a>steps for aborting a transaction</a> with <var>transaction</var>
and an appropriate for the error, for example <a>QuotaExceededError</a> or <a>UnknownError</a>.

<li>
<a>Queue a task</a> to dispatch an event at <var>transaction</var>.
The event must use the <a>Event</a> interface and have its <code>type</code> set to "<code>complete</code>".
The event does not bubble and is not cancelable.

<aside class=note>
Even if an exception is thrown from one of the event handlers of this event, the transaction is still
committed since writing the database changes happens before the event takes places. Only after the transaction
has been successfully written is the "<code>complete</code>" event fired.
</aside>

</ol>


<!-- ============================================================ -->
<h4 id=abort-transaction>Steps for aborting a transaction</h4>
<!-- ============================================================ -->

When taking the <dfn>steps for aborting a transaction</dfn> the implementation MUST
execute the following algorithm. This algorithm takes two arguments:
the <var>transaction</var> to abort,
and <var>error</var>.

<ol class=algorithm>
<li>
All the changes made to the <a>database</a> by the
<a>transaction</a> are reverted.

For <a>upgrade transactions</a> this includes changes to
the set of <a>object stores</a> and <a>indexes</a>,
as well as the change to the <a>version</a>. Any
<a>object stores</a> and <a>indexes</a> which were
created during the transaction are now considered
deleted for the purposes of other algorithms.

<li>
If <var>transaction</var> is an <a>upgrade transactions</a>,
run the  <a>steps for aborting an upgrade transaction</a>
with <var>transaction</var>. This reverts changes to all
<a>connection</a>,
<a>object store handle</a>, and
<a>index handle</a>
instances associated with <var>transaction</var>.

<li>
If <var>error</var> is not null, set <var>transaction</var>'s <a data-lt="transaction error">error</a>
to <var>error</var>.

<li>
For each <var>request</var> in <var>transaction</var>'s <a>request list</a>
with <a>done flag</a> unset,
abort the <a>steps for asynchronously executing a request</a> for <var>request</var> and
<a>queue a task</a> to run these substeps:
<ol>
<li>Set the <a>done flag</a> on <var>request</var>.
<li>Set the <a data-lt="request.result">result</a> of <var>request</var> to undefined.
<li>Set the <a data-lt="request.error">error</a> of <var>request</var> to a newly created <a>AbortError</a> exception.
<li>
Dispatch an event at <var>request</var>. The event must use
the <a>Event</a> interface and have its <code>type</code> set to "<code>error</code>".
The event bubbles and is cancelable.

</ol>
<aside class=note>
This does not always result in any <code>error</code> events being fired. For example if a transaction is aborted
due to an error while <a data-lt="transaction commit">committing</a> the transaction, or if it was the last remaining request
that failed.
</aside>

<li>
<a>Queue a task</a> to dispatch an event at <var>transaction</var>.
The event must use the <a>Event</a> interface and have its <code>type</code> set to "<code>abort</code>".
The event does bubble but is not cancelable.

</ol>


<!-- ============================================================ -->
<h4 id=async-execute-request>Steps for asynchronously executing a <a>request</a></h4>
<!-- ============================================================ -->

When taking the <dfn>steps for asynchronously executing a request</dfn> the implementation MUST run the
following algorithm. The algorithm takes a <var>source</var> object and an <var>operation</var> to
perform on a database, and an optional <var>request</var>.


These steps can be aborted at any point if the <a>transaction</a> the created <a>request</a> belongs
to is <a data-lt="transaction abort">aborted</a> using the <a>steps for aborting a transaction</a>

<ol class=algorithm>
<li>
Let <var>transaction</var> be the <a>transaction</a> associated with <var>source</var>.

<li>
If <var>transaction</var> is not <a>active</a>
throw a <a>TransactionInactiveError</a> exception.

<li>
If <var>request</var> was not given, let <var>request</var> be a new <var>request</var> with
<a data-lt="request.source">source</a> as <var>source</var>

<li>
Add <var>request</var> to the end of <var>transaction</var>'s <a>request list</a>.

<li>
Return <var>request</var> and queue up the execution of the remaining steps in this algorithm.

<li>
Wait until all previously added <a>requests</a> in <var>transaction</var> have their
<a>done flag</a> set.

<li>
Let <var>result</var> be the result of performing <var>operation</var>.

<li>
If <var>result</var> is an error, then revert all changes made by <var>operation</var>,
set the <a>done flag</a> on <var>request</var>,
set <a data-lt="request.result">result</a> of <var>request</var>
to undefined and set the <a data-lt="request.error">error</a> on <var>request</var>
to <var>result</var>.
Finally <a>fire an error event</a> at <var>request</var>.
<aside class=note>
This only reverts the changes done by this request, not any other changes made by the transaction.
</aside>

<li>
Otherwise, set the <a>done flag</a>
on the <var>request</var>, set <a data-lt="request.result">result</a> of <var>request</var>
to <var>result</var> set the <a data-lt="request.error">error</a> of <var>request</var> to undefined.
Finally <a>fire a success event</a> at <var>request</var>.

</ol>


<!-- ============================================================ -->
<h4 id=upgrade-transaction-steps>Upgrade transaction steps</h4>
<!-- ============================================================ -->

The <dfn>steps for running an upgrade transaction</dfn> are
as follows. This algorithm takes three arguments:
a <var>connection</var> object which is used to update the <a>database</a>,
a new <var>version</var> to be set for the <a>database</a>,
and a <var>request</var>.

<ol class=algorithm>
<li>
Let <var>openConnections</var> be the set of all <a>connections</a>,
except <var>connection</var>, connected to the same <a>database</a> as <var>connection</var>.

<li>
For each <var>entry</var> in <var>openConnections</var> that does not have its <a>close pending flag</a> set,
<a>fire a version change event</a> named <code>versionchange</code>
at <var>entry</var> with <var>db</var>'s <a>version</a> and <var>version</var>.
<aside class=note>
Firing this event might cause one or more of the other objects in <var>openConnections</var> to be closed, in which case
the <code>versionchange</code> event MUST NOT be fired at those objects if that hasn't yet been done.
</aside>

<li>
If any of the <a>connections</a> in <var>openConnections</var> are still not closed,
<a>fire a version change event</a> named <dfn><code>blocked</code></dfn>
at <var>request</var> with <var>db</var>'s <a>version</a> and <var>version</var>.

<li id="version-change-close-block">
Wait until all <a>connections</a> in <var>openConnections</var> are <a data-lt="database close">closed</a> and all of
their transactions are <a data-lt="transaction finish">finished</a>.

<li>
Let <var>transaction</var> be a new <a>upgrade transaction</a> with <var>connection</var> used as <a>connection</a>.
The <a>scope</a> of <var>transaction</var> includes every <a>object store</a> in <var>connection</var>.

<li>
Unset <var>transaction</var>'s <a>active flag</a>.

<li>
Start <var>transaction</var>. Note that until this <a>transaction</a> is finished,
no other <a>connections</a> can be opened to the same <a>database</a>.

<li>
Let <var>old version</var> be <var>database</var>'s <a>version</a>.

<li>
Set the version of <var>database</var> to <var>version</var>. This change is considered part of the
<a>transaction</a>, and so if the transaction is <a data-lt="transaction abort">aborted</a>, this change is reverted.

<li>
<a>Queue a task</a> to run the following steps:
<ol>
<li>
Set <var>request</var>'s <a data-lt="request.result">result</a> to <var>connection</var>.

<li>
Set <var>request</var>'s <a data-lt="request.transaction">transaction</a> to <var>transaction</var>.

<li>
Set the <a>done flag</a> on the <a>request</a>.

<li>
<a>Fire a version change event</a> named <dfn><code>upgradeneeded</code></dfn>
at <var>request</var> with <var>old version</var> and <var>version</var>.

<li>
If an exception was propagated out from any event handler while dispatching the event in the previous step, abort
the transaction by following the <a>steps for aborting a transaction</a> with the <var>error</var> property set to
a newly created <a>AbortError</a> exception.

</ol>

<li>
Execute transaction.

<li>
If <var>transaction</var> is aborted for any reason, the <a>steps for aborting a transaction</a> MUST be run.

<li>
When <var>transaction</var> is finished,
immediately set <var>request</var>'s <a data-lt="request.transaction">transaction</a> to null.

This MUST be done in the same task as the task firing the
<code>complete</code> or <code>abort</code> event, but after those events has been fired.

</ol>


<!-- ============================================================ -->
<h4 id=abort-upgrade-transaction>Steps for aborting an upgrade transaction</h4>
<!-- ============================================================ -->

The <dfn>steps for aborting an upgrade transaction</dfn> <var>transaction</var> are as follows.

<aside class=note>
The steps are run after the normal <a>steps for aborting a transaction</a>, which revert
changes to the <a>database</a> including the set of associated <a>object stores</a>
and <a>indexes</a>, as well as the change to the <a>version</a>.
</aside>
<ol class=algorithm>
<li>
Let <var>connection</var> be <var>transaction</var>'s <a>connection</a>.

<li>
Let <var>database</var> be <var>connection</var>'s <a>database</a>.

<li>
Set <var>connection</var>'s <a data-lt="connection.version">version</a> to <var>database</var>'s <a>version</a>
if <var>database</var> previously existed,
or 0 (zero) if <var>database</var> was newly created
<aside class=note>
This reverts the value of <code>version</code> returned by the {{IDBDatabase}} object.
</aside>

<li>
Set <var>connection</var>'s <a>object store set</a> to the
set of <a>object stores</a> in <var>database</var>
if <var>database</var> previously existed,
or the empty set if <var>database</var> was newly created.
<aside class=note>
This reverts the value of <code>objectStoreNames</code> returned by the {{IDBDatabase}} object.
</aside>

<li>
For each <a>object store handle</a> <var>handle</var> associated with <var>transaction</var>,
including <a data-lt="object store handle">handles</a> for <a>object stores</a>
that were deleted during <var>transaction</var>, run these substeps:
<ol>
<li>
Set <var>handle</var>'s <a data-lt="objectStoreHandle.name">name</a> to
its <a data-lt="objectStoreHandle.objectStore">object store</a>'s <a data-lt="objectStore.name">name</a>.

<li>
Set <var>handle</var>'s <a>index set</a> to the
set of <a>indexes</a> that reference its <a data-lt="objectStoreHandle.objectStore">object store</a>.

</ol>
<aside class=note>
This reverts the values of <code>name</code> and <code>indexNames</code> returned by related {{IDBObjectStore}} objects.


Although script cannot access an <a>object store</a> by using the
<code>objectStore()</code> method on an {{IDBTransaction}} instance after
the <a>transaction</a> is aborted, it may still have references to
{{IDBObjectStore}} instances where the <code>name</code> and <code>indexNames</code> properties
can be queried.

</aside>

<li>
For each <a>index handle</a> <var>handle</var> associated with <var>transaction</var>,
including <a data-lt="index handle">handles</a> for <a>indexes</a>
that were deleted during <var>transaction</var>, run these substeps:
<ol>
<li>
Set <var>handle</var>'s <a data-lt="indexHandle.name">name</a> to
its <a data-lt="indexHandle.index">index</a>'s <a data-lt="index.name">name</a>.

</ol>
<aside class=note>
This reverts the value of <code>name</code> returned by related {{IDBIndex}} objects.


Although script cannot access an <a>index</a> by using the
<code>index()</code> method on an {{IDBObjectStore}} instance after
the <a>transaction</a> is aborted, it may still have references to
{{IDBIndex}} instances where the <code>name</code> property
can be queried.

</aside>

</ol>

<aside class=note>
The <code>name</code> property of the {{IDBDatabase}} instance is not modified,
even if the aborted <a>upgrade transaction</a> was creating a new <a>database</a>.
</aside>


<!-- ============================================================ -->
<h4 id=fire-success-event>Fire a success event</h4>
<!-- ============================================================ -->

To <dfn>fire a success event</dfn> at a <a>request</a>,
the implementation MUST run the following steps:

<ol class=algorithm>
<li>
Set <var>transaction</var> to the <a>transaction</a> associated with the <a data-lt="request.source">source</a>.

<li>
Set the <a>active flag</a> of <var>transaction</var>.

<li>
Dispatch an event at <a>request</a>. The event must use
the <a>Event</a> interface and have its <code>type</code> set to "<code>success</code>".
The event does not bubble and is not cancelable.

<li>
Unset the <a>active flag</a> of <var>transaction</var>.

<li>
If an exception was propagated out from any event handler while dispatching the event in step 3,
abort the transaction by following the <a>steps for aborting a transaction</a> with
<var>transaction</var> and a newly created <a>AbortError</a> exception.

</ol>


<!-- ============================================================ -->
<h4 id=fire-error-event>Fire an error event</h4>
<!-- ============================================================ -->

To <dfn>fire an error event</dfn> at a <a><var>request</var></a>,
the implementation MUST run the following steps:

<ol class=algorithm>
<li>
Set <var>transaction</var> to the <a>transaction</a> associated with the <a data-lt="request.source">source</a>.

<li>
Set the <a>active flag</a> of <var>transaction</var>.

<li>
Dispatch an event at <var>request</var>. The event must use
the <a>Event</a> interface and have its <code>type</code> set to "<code>error</code>".
The event bubbles and is cancelable.

<li>
Unset the <a>active flag</a> of <var>transaction</var>.

<li>
If an exception was propagated out from any event handler while dispatching the event in step 3,
abort the transaction by following the <a>steps for aborting a transaction</a> with
<var>transaction</var> and a newly created <a>AbortError</a> exception and terminate these steps.
This is done even if the event's <a>canceled flag</a> is not set.
<aside class=note>
This means that if an error event is fired and any of the event handlers throw an exception,
<var>transaction</var>'s <code>error</code> property is set to an <a>AbortError</a> exception rather than <var>request</var>'s
<a data-lt="request.error">error</a>, even if <code>preventDefault()</code> is never called.
</aside>

<li>
If the event's <a>canceled flag</a> is not set,
run the <a>steps for aborting a transaction</a>
using <var>transaction</var> and <a>request</a>'s <a data-lt="request.error">error</a>.

</ol>



<!-- ============================================================ -->
<h3 id=database-operations>Database operations</h3>
<!-- ============================================================ -->

This section describes various operations done on the data in <a>object stores</a> and <a>indexes</a>
in a <a>database</a>. These operations are run by the <a>steps for asynchronously executing a request</a>.

<!-- ============================================================ -->
<h4 id=object-store-storage-operation>Object Store Storage Operation</h4>
<!-- ============================================================ -->

The <dfn>steps for storing a record into an object store</dfn> with
<var>store</var>,
<var>value</var>,
an optional <var>key</var>,
and a <var>no-overwrite flag</var>
are as follows.

<ol class=algorithm>
<li>
If <var>store</var> uses <a>in-line keys</a>, run these substeps:
<ol>
<li>Let <var>kpk</var> be the result of running the steps to <a>extract a key from a value using a key path</a>
with <var>value</var> and <var>store</var>'s <a data-lt="objectStore.keyPath">key path</a>.

<li>Assert: <var>kpk</var> will not be invalid or an exception.
<li>If <var>kpk</var> is not failure, let <var>key</var> be <var>kpk</var>.
</ol>

<li>
If <var>store</var> uses a <a>key generator</a>, run these substeps:
<ol>
<li>
If <var>key</var> is undefined, run these substeps:
<ol>
<li>
If the <a>key generator</a>'s <a>current number</a> is greater than 2<sup>53</sup> (9007199254740992),
then this operation failed with a <a>ConstraintError</a>. Abort this algorithm without taking
any further steps.

<li>Set <var>key</var> to the <a>key generator</a>'s <a>current number</a>
<li>Increase the <a>key generator</a>'s <a>current number</a> by 1.
<li>
If <var>store</var> also uses <a>in-line keys</a>, then run the steps to
<a>inject a key into a value using a key path</a> with <var>value</var>,
<var>key</var> and <var>store</var>'s <a data-lt="objectStore.keyPath">key path</a>.

</ol>

<li>
Otherwise, if the <a data-lt="key.type">type</a> of <var>key</var> is <i>number</i>
and the <a data-lt="key.value">value</a> is greater than or equal to the <a>key generator</a>'s
<a>current number</a>, set the <a>current number</a> to lowest integer greater than <var>key</var>.

</ol>

<li>
If the <var>no-overwrite flag</var> was given to these steps and is set, and
a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then
this operation failed with a <a>ConstraintError</a>. Abort this algorithm without taking
any further steps.

<li>
If a <a>record</a> already exists in <var>store</var> with its key <a>equal to</a> <var>key</var>, then
remove the <a>record</a> from <var>store</var> using the <a>steps for deleting records from an object store</a>.

<li>
Store a record in <var>store</var> containing <var>key</var> as its key and <var>value</var> as its
value. The record is stored in the object store's <a data-lt="object store record list">list</a> such
that the list is sorted according key of the records in ascending order.

<li>
For each <var>index</var> which <a>reference</a> <var>store</var>, run these substeps:
<ol>
<li>
Let <var>index key</var> be the result of running the steps to <a>extract a key from a value using a key path</a>
with <var>value</var>, <var>index</var>'s <a data-lt="index.keyPath">key path</a>,
and <var>index</var>'s <a>multiEntry flag</a>.

<li>If <var>index key</var> is an exception, or invalid, or failure, take no further actions for this index,
and continue these substeps for the next index.
<aside class=note>
An exception thrown in this step is not rethrown.
</aside>

<li>
If <var>index</var>'s <a>multiEntry flag</a> is unset, or if <var>index key</var> is not an <a>array key</a>,
and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> <var>index key</var>,
and <var>index</var> has its <a>unique flag</a> set, then this operation failed with a
<a>ConstraintError</a>. Abort this algorithm without taking any further steps.

<li>
If <var>index</var>'s <a>multiEntry flag</a> is set and <var>index key</var> is an <a>array key</a>,
and if <var>index</var> already contains a <a>record</a> with <a>key</a> <a>equal to</a> any of the
<a>subkeys</a> of <var>index key</var>, and <var>index</var> has its <a>unique flag</a> set, then this operation
failed with a <a>ConstraintError</a>. Abort this algorithm without taking any further steps.

<li>
If <var>index</var>'s <a>multiEntry flag</a> is unset, or if <var>index key</var> is not an <a>array key</a>
then store a record in <var>index</var> containing <var>index key</var> as its key and <var>key</var> as its
value. The record is stored in <var>index</var>'s <a data-lt="index record list">list of records</a> such
that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending
order.

<li>
If <var>index</var>'s <a>multiEntry flag</a> is set and <var>index key</var> is an <a>array key</a>,
then for each <var>subkey</var> of the <a>subkeys</a> of <var>index key</var> store a record in <var>index</var> containing
<var>subkey</var> as its key and <var>key</var> as its value. The records are stored in <var>index</var>'s
<a data-lt="index record list">list of records</a> such that the list is sorted primarily on the records keys,
and secondarily on the records values, in ascending order.
<aside class=note>
It is valid for there to be no <a>subkeys</a>. In this case no records are added to the index.
</aside>
<aside class=note>
Even if any member of <a>subkeys</a> is an <a>array key</a>, the member is used directly
as the key for the index record. Nested <a>array keys</a> are not flattened
or "unpacked" to produce multiple rows; only the outer-most <a>array key</a>
</aside>

</ol>

<li>
Return <var>key</var>.

</ol>


<!-- ============================================================ -->
<h4 id=object-store-retrieval-operation>Object Store Retrieval Operations</h4>
<!-- ============================================================ -->

The <dfn>steps for retrieving a value from an object store</dfn> with
<var>store</var> and <var>range</var> are as follows:


<ol class=algorithm>
<li>
Let <var>record</var> be the first <a>record</a> in <var>store</var>'s <a data-lt="object store record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>,
if any.

<li>
If <var>record</var> was not found, return undefined.

<li>
Return a <a>structured clone</a> of <var>record</var>'s value.

</ol>


The <dfn>steps for retrieving multiple values from an object store</dfn> with
<var>store</var>, <var>range</var> and optional <var>count</var> are as follows:


<ol class=algorithm>
<li>If <var>count</var> is not given or is 0 (zero), let <var>count</var> be infinity.
<li>
Let <var>records</var> be a list containing the first <var>count</var> <a>records</a>
in <var>store</var>'s <a data-lt="object store record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>.

<li>Let <var>array</var> be a new <a>Array</a> object.
<li>Let <var>index</var> be 0.
<li>For each <var>record</var> in <var>records</var>, run these substeps:
<ol>
<li>Let <var>entry</var> be a <a>structured clone</a> of <var>record</var>'s value.
<li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).
<li>Assert: <var>status</var> is true.
<li>Increase <var>index</var> by 1.
</ol>

<li>Return <var>array</var>
</ol>


The <dfn>steps for retrieving a key from an object store</dfn> with
<var>store</var> and <var>range</var> are as follows:


<ol class=algorithm>
<li>
Let <var>record</var> be the first <a>record</a> in <var>store</var>'s <a data-lt="object store record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>,
if any.

<li>
If <var>record</var> was not found, return undefined.

<li>
Return <var>record</var>'s key.

</ol>



The <dfn>steps for retrieving multiple keys from an object store</dfn> with
<var>store</var>, <var>range</var> and optional <var>count</var> are as follows:


<ol class=algorithm>
<li>If <var>count</var> is not given or is 0 (zero), let <var>count</var> be infinity.
<li>
Let <var>records</var> be a list containing the first <var>count</var> <a>records</a>
in <var>store</var>'s <a data-lt="object store record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>.

<li>Let <var>array</var> be a new <a>Array</a> object.
<li>Let <var>index</var> be 0.
<li>For each <var>record</var> in <var>records</var>, run these substeps:
<ol>
<li>Let <var>entry</var> be the result of running the steps to <a>convert a key to a value</a> with <var>record</var>'s key.
<li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).
<li>Assert: <var>status</var> is true.
<li>Increase <var>index</var> by 1.
</ol>

<li>Return <var>array</var>
</ol>


<!-- ============================================================ -->
<h4 id=index-retrieval-operation>Index Retrieval Operations</h4>
<!-- ============================================================ -->

The <dfn>steps for retrieving a referenced value from an index</dfn> with
<var>index</var> and <var>range</var> are as follows.

<ol class=algorithm>
<li>
Let <var>record</var> be the first <a>record</a>
in <var>index</var>'s <a data-lt="index record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>,
if any.

<li>
If <var>record</var> was not found, return undefined.

<li>
Return a <a>structured clone</a> of <var>record</var>'s <a>referenced value</a>.

</ol>


The <dfn>steps for retrieving multiple referenced values from an index</dfn> with
<var>index</var>, <var>range</var> and optional <var>count</var> are as follows:


<ol class=algorithm>
<li>If <var>count</var> is not given or is 0 (zero), let <var>count</var> be infinity.
<li>
Let <var>records</var> be a list containing the first <var>count</var> <a>records</a>
in <var>index</var>'s <a data-lt="index record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>.

<li>Let <var>array</var> be a new <a>Array</a> object.
<li>Let <var>index</var> be 0.
<li>For each <var>record</var> in <var>records</var>, run these substeps:
<ol>
<li>Let <var>entry</var> be a <a>structured clone</a> of <var>record</var>'s <a>referenced value</a>.
<li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).
<li>Assert: <var>status</var> is true.
<li>Increase <var>index</var> by 1.
</ol>

<li>Return <var>array</var>
</ol>


The <dfn>steps for retrieving a value from an index</dfn> with
<var>index</var> and <var>range</var> are as follows.


<ol class=algorithm>
<li>
Let <var>record</var> be the first <a>record</a>
in <var>index</var>'s <a data-lt="index record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>,
if any.

<li>
If <var>record</var> was not found, return undefined.

<li>
Return <var>record</var>'s <a>value</a>.

</ol>


The <dfn>steps for retrieving multiple values from an index</dfn> with
<var>index</var>, <var>range</var> and optional <var>count</var> are as follows:


<ol class=algorithm>
<li>If <var>count</var> is not given or is 0 (zero), let <var>count</var> be infinity.
<li>
Let <var>records</var> be a list containing the first <var>count</var> <a>records</a>
in <var>index</var>'s <a data-lt="index record list">list of records</a>
whose key is <a data-lt="in a key range">in</a> <var>range</var>.

<li>Let <var>array</var> be a new <a>Array</a> object.
<li>Let <var>index</var> be 0.
<li>For each <var>record</var> in <var>records</var>, run these substeps:
<ol>
<li>Let <var>entry</var> be the result of running the steps to <a>convert a key to a value</a> with <var>record</var>'s value.
<li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).
<li>Assert: <var>status</var> is true.
<li>Increase <var>index</var> by 1.
</ol>

<li>Return <var>array</var>
</ol>


<!-- ============================================================ -->
<h4 id=object-store-deletion-operation>Object Store Deletion Operation</h4>
<!-- ============================================================ -->

The <dfn>steps for deleting records from an object store</dfn>
with <var>store</var> and <var>range</var> are as follows.

<ol class=algorithm>
<li>
Remove all records, if any, from <var>store</var>'s <a data-lt="object store record list">list of records</a>
with key <a data-lt="in a key range">in</a> <var>range</var>.

<li>
For each <var>index</var> which <a>references</a> <var>store</var>, remove
every <a>record</a> from <var>index</var>'s <a data-lt="index record list">list of records</a>
whose value is <a data-lt="in a key range">in</a> <var>range</var>, if any such records exist.

<li>
Return undefined.

</ol>


<!-- ============================================================ -->
<h4 id=record-counting-operation>Record Counting Operation</h4>
<!-- ============================================================ -->

The <dfn>steps to count the records in a range</dfn> with <var>source</var> and <var>range</var> are as follows:

<ol class=algorithm>
<li>
Let <var>count</var> be the number of records, if any,
in <var>source</var>'s list of records with key <a data-lt="in a key range">in</a> <var>range</var>.

<li>
Return <var>count</var>.

</ol>


<!-- ============================================================ -->
<h4 id=object-store-clear-operation>Object Store Clear Operation</h4>
<!-- ============================================================ -->

The <dfn>steps for clearing an object store</dfn> with <var>store</var> are as follows.

<ol class=algorithm>
<li>
Remove all records from <var>store</var>.

<li>
In all <a>indexes</a> which <a>reference</a> <var>store</var>, remove all
<a>records</a>.

<li>
Return undefined.

</ol>


<!-- ============================================================ -->
<h4 id=cursor-iteration-operation>Cursor Iteration Operation</h4>
<!-- ============================================================ -->

The <dfn>steps for iterating a cursor</dfn> with <var>cursor</var>, an optional
<var>key</var> and <var>primaryKey</var> to iterate to, and an optional <var>count</var> are as follows.

<ol class=algorithm>
<li>Let <var>source</var> be <var>cursor</var>'s <a data-lt="cursor.source">source</a>.
<li>Let <var>direction</var> be <var>cursor</var>'s <a>direction</a>.
<li>Assert: if <var>primaryKey</var> is given, <var>source</var> is an <a>index</a> and
<var>direction</var> is "<code>next</code>" or "<code>prev</code>".

<li>Let <var>records</var> be the list of <a>records</a> in <var>source</var>.
<aside class=note>
<var>records</var> is always sorted in ascending <a>key</a> order. In the case of
<var>source</var> being an <a>index</a>, <var>records</var> is secondarily sorted in ascending
<a>value</a> order (where the value in an <a>index</a> is the <a>key</a> of the <a>record</a> in the referenced <a>object store</a>).
</aside>

<li>Let <var>range</var> be <var>cursor</var>'s <a>range</a>.

<li>Let <var>position</var> be <var>cursor</var>'s <a>position</a>.
<li>Let <var>object store position</var> be <var>cursor</var>'s <a>object store position</a>.

<li>If <var>count</var> is not given, let <var>count</var> be 1.
<li>While <var>count</var> is greater than 0, run these substeps:
<ol>
<li>
Switch on <var>direction</var>:
<dl class=switch>
<dt>"<code>next</code>"</dt>
<dd>
Let <var>found record</var> be the first record in <var>records</var> which
satisfy all of the following requirements:
<ul>
<li>
If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.

<li>
If <var>primaryKey</var> is defined,
the record's key is <a>equal to</a> <var>key</var>
and the record's value is <a>greater than</a> or <a>equal to</a> <var>primaryKey</var>, or
the record's key is <a>greater than</a> <var>key</var>.

<li>
If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
key is <a>greater than</a> <var>position</var>.

<li>
If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
key is <a>equal to</a> <var>position</var> and the record's value is <a>greater than</a>
<var>object store position</var> or the record's key is <a>greater than</a> <var>position</var>.

<li>
The record's key is <a data-lt="in a key range">in</a> <var>range</var>.

</ul>
</dd>
<dt>"<code>nextunique</code>"</dt>
<dd>
Let <var>found record</var> be the first record in <var>records</var> which
satisfy all of the following requirements:
<ul>
<li>
If <var>key</var> is defined, the record's key is <a>greater than</a> or <a>equal to</a> <var>key</var>.

<li>
If <var>position</var> is defined, the record's key is <a>greater than</a> <var>position</var>.

<li>
The record's key is <a data-lt="in a key range">in</a> <var>range</var>.

</ul>
</dd>
<dt>"<code>prev</code>"</dt>
<dd>
Let <var>found record</var> be the last record in <var>records</var> which
satisfy all of the following requirements:
<ul>
<li>
If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.

<li>
If <var>primaryKey</var> is defined,
the record's key is <a>equal to</a> <var>key</var>
and the record's value is <a>less than</a> or <a>equal to</a> <var>primaryKey</var>, or
the record's key is <a>less than</a> <var>key</var>.

<li>
If <var>position</var> is defined, and <var>source</var> is an <a>object store</a>, the record's
key is <a>less than</a> <var>position</var>.

<li>
If <var>position</var> is defined, and <var>source</var> is an <a>index</a>, the record's
key is <a>equal to</a> <var>position</var> and the record's value is <a>less than</a>
<var>object store position</var> or the record's key is <a>less than</a> <var>position</var>.

<li>
The record's key is <a data-lt="in a key range">in</a> <var>range</var>.

</ul>
</dd>
<dt>"<code>prevunique</code>"</dt>
<dd>
Let <var>temp record</var> be the last record in
<var>records</var> which satisfy all of the following requirements:
<ul>
<li>
If <var>key</var> is defined, the record's key is <a>less than</a> or <a>equal to</a> <var>key</var>.

<li>
If <var>position</var> is defined, the record's key is <a>less than</a> <var>position</var>.

<li>
The record's key is <a data-lt="in a key range">in</a> <var>range</var>.

</ul>
If <var>temp record</var> is defined, let <var>found record</var> be the first record in <var>records</var>
whose key is <a>equal to</a> <var>temp record</var>'s key.
</dd>
</dl>

<li>
If <var>found record</var> is not defined, run these substeps:
<ol>
<li>Set <var>cursor</var>'s <a data-lt="cursor.key">key</a> to undefined.
<li>If <var>source</var> is an <a>index</a>,
set <var>cursor</var>'s <a>object store position</a> to undefined.
<li>If <var>cursor</var>'s <a>key only flag</a> is unset,
set <var>cursor</var>'s <a data-lt="cursor.value">value</a> to undefined.
<li>Return null.
</ol>


<li>Let <var>position</var> be <var>found record</var>'s key.
<li>If <var>source</var> is an <a>index</a>,
let <var>object store position</var> be <var>found record</var>'s value.
<li>Decrease <var>count</var> by 1.
</ol>

<li>Set <var>cursor</var>'s <a>position</a> to <var>position</var>.
<li>If <var>source</var> is an <a>index</a>,
set <var>cursor</var>'s <a>object store position</a> to <var>object store position</var>.
<li>Set <var>cursor</var>'s <a data-lt="cursor.key">key</a> to <var>found record</var>'s key.
<li>If <var>cursor</var>'s <a>key only flag</a> is unset,
set <var>cursor</var>'s <a data-lt="cursor.value">value</a> to a <a>structured clone</a> of <var>found record</var>'s <a>referenced value</a>.
<li>Set <var>cursor</var>'s <a>got value flag</a>.
<li>Return <var>cursor</var>.
</ol>



<!-- ============================================================ -->
<h3 id=binding>ECMAScript binding</h3>
<!-- ============================================================ -->

This section defines how <a>key</a> values defined in this specification
are converted to and from ECMAScript values, and how they may be
extracted from and injected into ECMAScript values using <a>key paths</a>.
This section references
types and algorithms from the ECMAScript Language Specification. [[!ECMA-262]]


<aside class="issue">
  Simplify this section as much as possible by relying more on [[!WEBIDL]]
  for key conversion logic.
</aside>

<!-- ============================================================ -->
<h4 id=extract-key-from-value>Steps to extract a key from a value using a <a>key path</a></h4>
<!-- ============================================================ -->


The steps to <dfn>extract a key from a value using a key path</dfn>
with <var>value</var>, <var>keyPath</var> and an optional
<var>multiEntry flag</var> are as follows.
The result of these steps is a <a>key</a>, invalid, or failure,
or the steps may throw an exception.

<ol class=algorithm>
<li>
Let <var>r</var> be the result of running the steps to
<a>evaluate a key path on a value</a> with <var>value</var> and <var>keyPath</var>.
If this throws an exception, <a>rethrow</a> it.

<li>If <var>r</var> is failure, return failure.
<li>Let <var>key</var> be
the result of running the steps to <a>convert a value to a key</a> with <var>r</var> if the <var>multiEntry flag</var> is unset, and
the result of running the steps to <a>convert a value to a multiEntry key</a> with <var>r</var> otherwise.
If this throws an exception, <a>rethrow</a> it.
<li>If <var>key</var> is invalid, return invalid.
<li>Return <var>key</var>.
</ol>


The steps to <dfn>evaluate a key path on a value</dfn>
with <var>value</var> and <var>keyPath</var> are as follows.
The result of these steps is an ECMAScript value
or failure, or the steps may throw an exception.

<ol class=algorithm>
<li>
If <var>keyPath</var> is a <a>sequence&lt;DOMString&gt;</a>, run these substeps:
<ol>
<li>Let <var>result</var> be a new <a>Array</a> ECMAScript object.
<li>For each <var>item</var> in the <var>keyPath</var> sequence, run these substeps:
<ol>
<li>Let <var>key</var> be the result of recursively running the steps to <a>extract a key from a value using a key path</a>
using <var>item</var> as <var>keyPath</var> and <var>value</var> as <var>value</var>.
<li>ReturnIfAbrupt(<var>key</var>)
<li>If <var>key</var> is failure, abort the overall algorithm and return failure.
<li>Append the result of the first sub-step to end of <var>result</var>.
</ol>

<li>
Return <var>result</var>.
<aside class=note>
This will only ever "recurse" one level since <a>key path</a> sequences can't ever be nested.
</aside>

</ol>

<li>
If <var>keyPath</var> is the empty string, return <var>value</var> and skip the remaining steps.

<li>
Let <var>identifiers</var> be the result of <a>strictly splitting the string</a> <var>keyPath</var> on
U+002E FULL STOP characters (.).

<li>
For each <var>identifier</var> in <var>identifiers</var>, run these substeps:
<ol>
<li>If Type(<var>value</var>) is String, and <var>identifier</var> is the last item in <var>identifiers</var>,
and <var>identifier</var> is "<code>length</code>", return a Number equal to the number of elements in <var>value</var>.
<li>If Type(<var>value</var>) is not Object, return failure.
<li>Let <var>value</var> be <var>value</var>.[<span>[</span>Get]](<var>identifier</var>, <var>value</var>)
<li>ReturnIfAbrupt(<var>value</var>)
<li>If <var>value</var> is Undefined, return failure.
</ol>

<li>
Return <var>value</var>.

</ol>


<!-- ============================================================ -->
<h4 id=inject-key-into-value>Steps to inject a key into a value using a key path</h4>
<!-- ============================================================ -->

The steps to <dfn>inject a key into a value using a key path</dfn> are as follows.
The algorithm takes a <var>value</var>, a <var>key</var> and a <var>keyPath</var>.

<ol class=algorithm>
<li>
Let <var>identifiers</var> be the result of
<a>strictly splitting the string</a>
<var>keyPath</var> on U+002E FULL STOP characters (.).

<li>Assert: <var>identifiers</var> is not empty.
<li>
Let <var>last</var> be the last member of <var>identifiers</var>
and remove it from the list.

<li>For each remaining <var>identifier</var> in <var>identifiers</var>, run these substeps:
<ol>
<li>
If <var>value</var> is not an <a>Object</a> object or an <a>Array</a>
object (see <a>structured clone algorithm</a> [[!HTML]]), then
throw a <a>DataError</a> exception.

<li>Let <var>hop</var> be HasOwnProperty(<var>value</var>, <var>identifier</var>)
<li>Assert: <var>hop</var> is not an abrupt completion.
<li>
If <var>hop</var> is false, run these substeps:
<ol>
<li>Let <var>o</var> be a new <a>Object</a>.
<li>Let <var>status</var> be
CreateDataProperty(<var>value</var>, <var>identifier</var>, <var>o</var>)
<li>Assert: <var>status</var> is true
</ol>

<li>Let <var>value</var> be
<var>value</var>.[<span>[</span>Get]](<var>identifier</var>, <var>value</var>)
<li>Assert: <var>value</var> is not an abrupt completion.
</ol>

<li>Assert: <var>value</var> is an <a>Object</a> or an <a>Array</a>.
<li>Let <var>keyValue</var> be the result of running the steps to
<a>convert a key to a value</a>.
<li>Let <var>status</var> be
CreateDataProperty(<var>value</var>, <var>last</var>, <var>keyValue</var>)
<li>Assert: <var>status</var> is true
</ol>

<aside class=note>
The <a>key path</a> used here is always a string and never a sequence, since it is not
possible to create a <a>object store</a> which has a <a>key generator</a> and
also has a <a data-lt="objectStore.keyPath">key path</a> that is a sequence.
</aside>

<aside class=note>
Assertions can be made in the above steps because this algorithm
is only applied to values that are the output of the
<a>structured clone algorithm</a>.
</aside>


<!-- ============================================================ -->
<h4 id=convert-key-to-value>Steps to convert a key to a value</h4>
<!-- ============================================================ -->

The steps to <dfn>convert a key to a value</dfn> are as follows. These
steps take one argument, <var>key</var>, and return an ECMAScript value.

<ol class=algorithm>
<li>Let <var>type</var> be <var>key</var>'s <a data-lt="key.type">type</a>.
<li>Let <var>value</var> be <var>key</var>'s <a data-lt="key.value">value</a>.
<li>Switch on <var>type</var>:
<dl class=switch>
<dt><i>number</i></dt>
<dd>Return an ECMAScript Number value equal to <var>value</var></dd>

<dt><i>string</i></dt>
<dd>Return an ECMAScript String value equal to <var>value</var></dd>

<dt><i>date</i></dt>
<dd>
<ol>
<li>Let <var>date</var> be the result of executing the ECMAScript Date constructor with
the single argument <var>value</var>
<li>Assert: <var>date</var> is not an abrupt completion.
<li>Return <var>date</var>
</ol>
</dd>

<dt><i>binary</i></dt>
<dd>
<ol>
<li>Let <var>len</var> be the length of <var>value</var>.
<li>Let <var>buffer</var> be the result of executing the ECMAScript ArrayBuffer constructor with <var>len</var>.
<li>Assert: <var>buffer</var> is not an abrupt completion.
<li>Set the entries in <var>buffer</var>'s [<span>[</span>ArrayBufferData]] internal slot to the entries in <var>value</var>.
<li>Return <var>buffer</var>
</ol>
</dd>

<dt><i>array</i></dt>
<dd>
<ol>
<li>Let <var>array</var> be the result of executing the ECMAScript Array constructor with no arguments.
<li>Assert: <var>array</var> is not an abrupt completion.
<li>Let <var>len</var> be the length of <var>value</var>.
<li>Let <var>index</var> be 0.
<li>While <var>index</var> is less than <var>len</var>, run these substeps:
<ol>
<li>Let <var>entry</var> be the result of running the steps to <a>convert a key to a value</a>
with the <var>index</var>th entry of <var>value</var> as input.
<li>Let <var>status</var> be CreateDataProperty(<var>array</var>, <var>index</var>, <var>entry</var>).
<li>Assert: <var>status</var> is true.
<li>Increase <var>index</var> by 1.
</ol>

<li>Return <var>array</var>
</ol>
</dd>
</dl>

</ol>


<!-- ============================================================ -->
<h4 id=convert-value-to-key>Steps to convert a value to a key</h4>
<!-- ============================================================ -->

The steps to <dfn>convert a value to a key</dfn> are as follows. These
steps take two arguments, an ECMAScript value <var>input</var>, and
an optional set <var>seen</var>. The result of these steps is a <a>key</a> or invalid,
or the steps may throw an exception.

<ol class=algorithm>
<li>If <var>seen</var> was not given, let <var>seen</var> be a new empty set
<li>If <var>input</var> is in <var>seen</var> return invalid
<li>Jump to the appropriate step below:
<dl class=switch>

<!-- Number -->
<dt>If Type(<var>input</var>) is Number</dt>
<dd>
<ol>
<li>If <var>input</var> is NaN then return invalid.
<li>Otherwise, return a new <a>key</a> with <a data-lt="key.type">type</a> <i>number</i>
and <a data-lt="key.value">value</a> <var>input</var>
</ol>
</dd>

<!-- Date -->
<dt>If <var>input</var> has an [<span>[</span>DateValue]] internal slot</dt>
<dd>
<ol>
<li>Let <var>ms</var> be the value of <var>input</var>'s [<span>[</span>DateValue]] internal slot.
<li>If <var>ms</var> is NaN then return invalid.
<li>Otherwise, return a new <a>key</a> with <a data-lt="key.type">type</a> <i>date</i> and <a data-lt="key.value">value</a> <var>ms</var>.
</ol>
</dd>

<!-- String -->
<dt>If Type(<var>input</var>) is String</dt>
<dd>
<ol>
<li>Return a new <a>key</a> with <a data-lt="key.type">type</a> <i>string</i> and <a data-lt="key.value">value</a> <var>input</var>.
</ol>
</dd>

<!-- Binary -->
<dt>If <var>input</var> has an [<span>[</span>ArrayBufferData]] internal slot
or an [<span>[</span>ViewedArrayBuffer]] internal slot</dt>
<dd>
<ol>
<li>
Let <var>octets</var> be the result of running the steps for
<a>getting a copy of the bytes held by a buffer source</a> with <var>value</var>.
If this throws an exception, <a>rethrow</a> it.

<li>Return a new <a>key</a> with <a data-lt="key.type">type</a> <i>binary</i> and <a data-lt="key.value">value</a> <var>octets</var>.
</ol>
</dd>

<!-- Array -->
<dt>If IsArray(<var>input</var>)</dt>
<dd>
<ol>
<li>Let <var>len</var> be the ToLength(Get(<var>input</var>, "<code>length</code>"))
<li>Assert: <var>len</var> will never an abrupt completion.
<li>Add <var>input</var> to <var>seen</var>
<li>Let <var>keys</var> be a new empty list
<li>Let <var>index</var> be 0
<li>While <var>index</var> is less than <var>len</var>, run these substeps:
<ol>
<li>Let <var>entry</var> be <var>input</var>.[<span>[</span>Get]](<var>index</var>, <var>input</var>)
<li>ReturnIfAbrupt(<var>entry</var>)
<li>Let <var>key</var> be the result of running the steps to <a>convert a value to a key</a>
with arguments <var>entry</var> and <var>seen</var>
<li>ReturnIfAbrupt(<var>key</var>)
<li>If <var>key</var> is invalid or an exception, then abort these steps and return <var>key</var>.
<li>Append <var>key</var> to <var>keys</var>
<li>Increase <var>index</var> by 1
</ol>

<li>Return a new <a>array key</a> with <a data-lt="key.value">value</a> <var>keys</var>.
</ol>
</dd>

<dt>Otherwise</dt>
<dd>Return invalid</dd>
</dl>

</ol>


The steps to <dfn>convert a value to a multiEntry key</dfn> are as follows. These
steps take one argument, an ECMAScript value <var>input</var>.
The result of these steps is a <a>key</a> or invalid, or the steps may throw an exception.

<ol class=algorithm>
<!-- Array -->
<li>If IsArray(<var>input</var>), then:
<ol>
<li>Let <var>len</var> be the ToLength(Get(<var>input</var>, "<code>length</code>")).
<li>Assert: <var>len</var> will never an abrupt completion.
<li>Let <var>seen</var> be a new set containing only <var>input</var>.
<li>Let <var>keys</var> be a new empty set.
<li>Let <var>index</var> be 0.
<li>While <var>index</var> is less than <var>len</var>, run these substeps:
<ol>
<li>Let <var>entry</var> be <var>input</var>.[<span>[</span>Get]](<var>index</var>, <var>input</var>)
<li>If <var>entry</var> is not an exception, run these substeps:
<ol>
<li>Let <var>key</var> be the result of running the steps to <a>convert a value to a key</a>
with arguments <var>entry</var> and <var>seen</var>
<li>If <var>key</var> is not invalid or an exception, add <var>key</var> to <var>keys</var>
if there are no other members of <var>keys</var> <a>equal to</a> <var>key</var>
</ol>

<li>Increase <var>index</var> by 1
</ol>

<li>Return a new <a>array key</a> with <a data-lt="key.value">value</a> set to
a list of the members of <var>keys</var>.

</ol>

<li>Otherwise, return the result of running the steps to <a>convert a value to a key</a>
with argument <var>input</var>.

</ol>

<aside class=note>
  These steps are similar to those to <a>convert a value to a key</a>
  but if the top-level value is an <a>Array</a> then members which can
  not be converted to keys are ignored, and duplicates are removed.

  For example, the value <code>[10, 20, null, 30, 20]</code> is
  converted to an <a>array key</a> with <a>subkeys</a> 10, 20, 30.
</aside>





<!-- ============================================================ -->
<h2 id=privacy>Privacy</h2>
<!-- ============================================================ -->

<h3 id=user-tracking>User tracking</h3>

A third-party host (or any object capable of getting content
distributed to multiple sites) could use a unique identifier stored in
its client-side database to track a user across multiple sessions,
building a profile of the user's activities. In conjunction with a
site that is aware of the user's real id object (for example an
e-commerce site that requires authenticated credentials), this could
allow oppressive groups to target individuals with greater accuracy
than in a world with purely anonymous Web usage.

There are a number of techniques that can be used to mitigate the risk
of user tracking:


<dl>
<dt>Blocking third-party storage</dt>
<dd>
User agents MAY restrict access to the database objects
to scripts originating at the domain of the top-level document of
the <span>browsing context</span>, for instance denying access to
the API for pages from other domains running in <code>iframe</code>s.
</dd>

<dt>Expiring stored data</dt>
<dd>

User agents MAY automatically delete stored data after a period
of time.

This can restrict the ability of a site to track a user, as the
site would then only be able to track the user across multiple
sessions when she authenticates with the site itself (e.g. by
making a purchase or logging in to a service).


However, this also puts the user's data at risk.
</dd>

<dt>Treating persistent storage as cookies</dt>
<dd>

User agents should present the database feature
to the user in a way that associates them strongly with HTTP
session cookies. [[COOKIES]]

This might encourage users to view such storage with healthy
suspicion.

</dd>

<dt>Site-specific white-listing of access to databases</dt>
<dd>

User agents MAY require the user to authorize access to
databases before a site can use the feature.

</dd>

<dt>Origin-tracking of stored data</dt>
<dd>

User agents MAY record the <a>origins</a>
of sites that contained content from third-party origins that
caused data to be stored.

If this information is then used to present the view of data
currently in persistent storage, it would allow the user to make
informed decisions about which parts of the persistent storage to
prune. Combined with a blacklist ("delete this data and prevent
this domain from ever storing data again"), the user can restrict
the use of persistent storage to sites that she trusts.

</dd>

<dt>Shared blacklists</dt>
<dd>

User agents MAY allow users to share their persistent storage
domain blacklists.

This would allow communities to act together to protect their
privacy.

</dd>
</dl>

While these suggestions prevent trivial use of this API for user
tracking, they do not block it altogether. Within a single domain, a
site can continue to track the user during a session, and can then
pass all this information to the third party along with any
identifying information (names, credit card numbers, addresses)
obtained by the site. If a third party cooperates with multiple
sites to obtain such information, a profile can still be
created.

However, user tracking is to some extent possible even with no
cooperation from the user agent whatsoever, for instance by using
session identifiers in URLs, a technique already commonly used for
innocuous purposes but easily repurposed for user tracking (even
retroactively). This information can then be shared with other
sites, using using visitors' IP addresses and other user-specific
data (e.g. user-agent headers and configuration settings) to combine
separate sessions into coherent user profiles.

<h3 id=cookie-resurrection>Cookie resurrection</h3>

If the user interface for persistent storage presents data in the
persistent storage features described in this specification
separately from data in HTTP session cookies, then users are likely
to delete data in one and not the other. This would allow sites to
use the two features as redundant backup for each other, defeating a
user's attempts to protect his privacy.


<h3 id=sensitivity-of-data>Sensitivity of data</h3>

User agents should treat persistently stored data as potentially
sensitive; it is quite possible for e-mails, calendar appointments,
health records, or other confidential documents to be stored in this
mechanism.

To this end, user agents should ensure that when deleting data,
it is promptly deleted from the underlying storage.


<!-- ============================================================ -->
<h2 id=authorization>Authorization</h2>
<!-- ============================================================ -->

<h3 id=dns-spoofing-attacks>DNS spoofing attacks</h3>

Because of the potential for DNS spoofing attacks, one cannot
guarantee that a host claiming to be in a certain domain really is
from that domain. To mitigate this, pages can use SSL. Pages using
SSL can be sure that only pages using SSL that have certificates
identifying them as being from the same domain can access their
databases.


<h3 id=cross-directory-attacks>Cross-directory attacks</h3>

Different authors sharing one host name, for example users
hosting content on <code>geocities.com</code>, all share one
set of databases.

There is no feature to restrict the access by pathname. Authors on
shared hosts are therefore recommended to avoid using these
features, as it would be trivial for other authors to read the data
and overwrite it.

<aside class=note>
  Even if a path-restriction feature was made available, the usual DOM
  scripting security model would make it trivial to bypass this
  protection and access the data from any path.
</aside>

<h3 id=implementation-risks>Implementation risks</h3>

The two primary risks when implementing these persistent storage
features are letting hostile sites read information from other
domains, and letting hostile sites write information that is then
read from other domains.

Letting third-party sites read data that is not supposed to be
read from their domain causes <em>information leakage</em>, For
example, a user's shopping wish list on one domain could be used by
another domain for targeted advertising; or a user's
work-in-progress confidential documents stored by a word-processing
site could be examined by the site of a competing company.

Letting third-party sites write data to the persistent storage of
other domains can result in <em>information spoofing</em>, which is
equally dangerous. For example, a hostile site could add records to a
user's wish list; or a hostile site could set a user's session
identifier to a known ID that the hostile site can then use to track
the user's actions on the victim site.

Thus, strictly following the <span>origin</span> model described
in this specification is important for user security.


<!-- ============================================================ -->
<h2 id=revision-history>Revision History</h2>
<!-- ============================================================ -->

The following is an informative summary of the changes since the last
publication of this specification.
A complete revision history can be found
<a href="https://github.com/w3c/IndexedDB/">here</a>.
For the revision history of the First Edition, see
<a href="https://www.w3.org/TR/IndexedDB/#revision-history">that
document's Revision History</a>.


* Address comparison of empty arrays.
    (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27712">bug #27712</a>)

* Added {{IDBObjectStore/openKeyCursor()}}.
    (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19955">bug #19955</a>)

* Correct <var>source</var> used for
    {{IDBIndex/get()}},
    {{IDBIndex/getKey()}} and
    {{IDBIndex/openKeyCursor()}}.

* Added details around garbage collection of {{IDBDatabase}} objects.
    (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=25223">bug #25223</a>)

* Added <code>[Exposed=(Window,Worker)]</code> annotations to interfaces.

* Added <var>forced flag</var> to the <a>steps for closing a database connection</a>,
    described the firing of a "<code>close</code>" event, and
    {{IDBDatabase/onclose}}.
    (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22540">bug #22540</a>)

* Converted specification to a more algorithmic style,
    and define abstract types such as <a>key</a> more rigorously.
    (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=17681">bug #17681</a>)

* Added
    {{IDBObjectStore/getAll()}},
    {{IDBObjectStore/getAllKeys()}},
    {{IDBIndex/getAll()}},
    {{IDBIndex/getAllKeys()}}.
    (<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=16595">bug #16595</a>)

* Replaced {{DOMError}} with <a>DOMException</a>.
    (<a href="https://github.com/w3c/IndexedDB/issues/16">bug #16</a>)

* Added {{IDBTransaction/objectStoreNames}}.
    (<a href="https://github.com/w3c/IndexedDB/issues/18">bug #18</a>)

* Added <i>binary</i> <a>keys</a>, including comparisons and ECMAScript bindings.
    (<a href="https://github.com/w3c/IndexedDB/issues/21">bug #21</a>)

* Allow renaming stores and indexes via {{IDBObjectStore/name}}
    and {{IDBIndex/name}} attribute setters.
    (<a href="https://github.com/w3c/IndexedDB/issues/21">bug #22</a>)

* Added {{IDBCursor/continuePrimaryKey()}}.
    (<a href="https://github.com/w3c/IndexedDB/issues/14">bug #14</a>)

* Added {{IDBKeyRange/includes()}}.
    (<a href="https://github.com/w3c/IndexedDB/issues/41">bug #41</a>)

* Added {{IDBObjectStore/getKey()}}.
    (<a href="https://github.com/w3c/IndexedDB/issues/26">bug #26</a>)


<!-- ============================================================ -->
<h2 id=acknowledgements>Acknowledgements</h2>
<!-- ============================================================ -->

Special thanks to Nikunj Mehta, the original author of
the first edition, and Jonas Sicking, Eliot Graff, Andrei Popescu,
and Jeremy Orlow, additional editors of the First Edition.

Garret Swart was extremely influential in the design of this specification.

Thanks to Tab Atkins, Jr. for creating and maintaining <a
href="https://github.com/tabatkins/bikeshed">Bikeshed</a>, the
specification authoring tool used to create this document.

Special thanks to
Chris Anderson,
Pablo Castro,
Kristof Degrave,
Jake Drew,
Ben Dilts,
Jo&atilde;o Eiras,
Alec Flett,
Dana Florescu,
David Grogan,
Israel Hilerio,
Kyle Huey,
Laxminarayan G Kamath A,
Anne van Kesteren,
Adam Klein,
Tobie Langel,
Kang-Hao Lu,
Andrea Marchesini,
Glenn Maynard,
Ms2ger,
Odin Omdal,
Danillo Paiva,
Olli Pettay,
Simon Pieters,
Yonathan Randolph,
Arun Ranganathan,
Margo Seltzer,
Maciej Stachowiak,
Ben Turner,
Kyaw Tun,
Hans Wennborg,
Shawn Wilsher,
Boris Zbarsky,
Zhiqiang Zhang,
and
Kris Zyp,
all of whose feedback and suggestions have led to improvements to this specification.
